
/** BEGIN_INPUT_DEFINITION *********************************************
 *
 * All specifications as seen by the parser.
 *
 * Do not edit - automatically generated.
 */

/**********************************************************
 * Dump of all structures:
 */

DUMMY()
{
  UINT32 no NOENCODE;
}

FEBEX_PADDING()
{
  UINT32 pads_data NOENCODE
  {
     0_11: counter;
    12_19: index;
    20_31: 0xadd;
  }
}

FEBEX_TRACES()
{
  MEMBER(DATA8 ftrigger);
  MEMBER(DATA8 fboard);
  MEMBER(DATA32 ftrig_time_hi);
  MEMBER(DATA32 ftrig_time_lo);
  MEMBER(DATA32 fts_hi[16] ZERO_SUPPRESS_MULTI(32));
  MEMBER(DATA32 fts_lo[16] ZERO_SUPPRESS_MULTI(32));
  MEMBER(DATA32 fen[16] ZERO_SUPPRESS_MULTI(32));
  MEMBER(DATA32 flength[16] ZERO_SUPPRESS);
  MEMBER(DATA16 ftrace[16][4000] ZERO_SUPPRESS);
  UINT32 FF_header NOENCODE
  {
     0_07: three_four;
     8_11: trigger_type;
    12_15: sfp;
    16_23: board_id;
    24_31: 255;
    ENCODE(ftrigger,(value=trigger_type));
    ENCODE(fboard,(value=board_id));
  }
  UINT32 febex_chan_size NOENCODE
  {
     0_01: ignore;
     2_31: size;
  }
  UINT32 febex_half_time NOENCODE
  {
     0_15: ext_time;
    16_31: other;
    ENCODE(ftrig_time_hi,(value=ext_time));
  }
  UINT32 febex_event_time NOENCODE
  {
     0_31: time;
    ENCODE(ftrig_time_lo,(value=time));
  }
  UINT32 febex_flags NOENCODE
  {
     0_15: hit_pattern;
    16_31: pile_flags;
  }
  UINT32 deadbeef NOENCODE
  {
     0_31: 0xdeadbeef;
  }
  if((FF_header.trigger_type == 3))
  {
    list(0<=i<16)
    {
      UINT32 pulse_header NOENCODE
      {
         0_07: 52;
         8_31: stuff;
      }
      UINT32 pulse_trace_size NOENCODE
      {
         0_31: size;
      }
      UINT32 pulse_trace_header NOENCODE
      {
         0_31: head;
      }
      UINT32 pulse_trace_trailer NOENCODE
      {
         0_31: trailer;
      }
    }
  }
  else
  {
    list(0<=i<((febex_chan_size.size / 4) - 1))
    {
      UINT32 F0_header NOENCODE
      {
         0_15: ext_chan_ts;
        16_23: ch_id;
        24_31: 240;
        ENCODE(fts_hi[i],(value=ext_chan_ts));
      }
      UINT32 febex_chan_ts NOENCODE
      {
         0_31: chan_ts;
        ENCODE(fts_lo[i],(value=chan_ts));
      }
      UINT32 febex_chan_en NOENCODE
      {
         0_23: chan_en;
        24_29: cf;
           30: pileup;
           31: overflow;
        ENCODE(fen[F0_header.ch_id],(value=chan_en));
      }
      UINT32 future_use NOENCODE
      {
         0_31: future;
      }
    }
    list(0<=i<16)
    {
      UINT32 header NOENCODE
      {
         0_07: 52;
         8_23: other;
        24_31: ch_id;
      }
      UINT32 tracesize NOENCODE
      {
         0_31: size;
      }
      UINT32 tracehead NOENCODE
      {
         0_23: other;
        24_31: head;
      }
      ENCODE(flength[header.ch_id],(value=((tracesize.size / 2) - 4)));

      list(0<=j<((tracesize.size / 4) - 2))
      {
        UINT32 channel_trace NOENCODE
        {
           0_13: data1;
          14_15: stuff1;
          16_29: data2;
          30_31: stuff2;
          ENCODE(ftrace[header.ch_id][((2 * j) + 0)],(value=data1));
          ENCODE(ftrace[header.ch_id][((2 * j) + 1)],(value=data2));
        }
      }
      UINT32 trace_trailer NOENCODE
      {
         0_23: notused;
        24_31: id = RANGE(176,191);
      }
    }
  }
}

TIMESTAMP_WHITERABBIT(id)
{
  MEMBER(DATA12 subsystem_id);
  MEMBER(DATA16 t1);
  MEMBER(DATA16 t2);
  MEMBER(DATA16 t3);
  MEMBER(DATA16 t4);
  UINT32 header NOENCODE
  {
     0_11: id = MATCH(id);
    12_15: 0;
       16: error_bit;
    17_31: 0;
    ENCODE(subsystem_id,(value=id));
  }
  UINT32 d1 NOENCODE
  {
     0_15: t1;
    16_31: 0x3e1;
    ENCODE(t1,(value=t1));
  }
  UINT32 d2 NOENCODE
  {
     0_15: t2;
    16_31: 0x4e1;
    ENCODE(t2,(value=t2));
  }
  UINT32 d3 NOENCODE
  {
     0_15: t3;
    16_31: 0x5e1;
    ENCODE(t3,(value=t3));
  }
  UINT32 d4 NOENCODE
  {
     0_15: t4;
    16_31: 0x6e1;
    ENCODE(t4,(value=t4));
  }
}

TIMESTAMP_WHITERABBIT_EXTENDED(id)
{
  MEMBER(DATA16 subsystem_id);
  MEMBER(DATA16 t1);
  MEMBER(DATA16 t2);
  MEMBER(DATA16 t3);
  MEMBER(DATA16 t4);
  UINT32 header NOENCODE
  {
     0_12: id = MATCH(id);
    13_15: 0;
       16: error_bit;
    17_31: 0;
    ENCODE(subsystem_id,(value=id));
  }
  UINT32 d1 NOENCODE
  {
     0_15: t1;
    16_31: 0x3e1;
    ENCODE(t1,(value=t1));
  }
  UINT32 d2 NOENCODE
  {
     0_15: t2;
    16_31: 0x4e1;
    ENCODE(t2,(value=t2));
  }
  UINT32 d3 NOENCODE
  {
     0_15: t3;
    16_31: 0x5e1;
    ENCODE(t3,(value=t3));
  }
  UINT32 d4 NOENCODE
  {
     0_15: t4;
    16_31: 0x6e1;
    ENCODE(t4,(value=t4));
  }
}

WR_MULTI()
{
  MEMBER(DATA32 time_hi);
  MEMBER(DATA32 time_lo);
  UINT32 hi NOENCODE
  {
     0_31: time;
    ENCODE(time_hi,(value=time));
  }
  UINT32 lo NOENCODE
  {
     0_31: time;
    ENCODE(time_lo,(value=time));
  }
}

SUBEVENT(febex_subev)
{
  if(0)
  {
    wr = TIMESTAMP_WHITERABBIT(id=0x400);
  }
  select several
  {
    padding = FEBEX_PADDING();
  }
  data = FEBEX_TRACES();
}

/**********************************************************
 * The event definition:
 */

EVENT
{
  trace = febex_subev(procid=60);
  ignore_unknown_subevent;
}

/**********************************************************
 * The sticky_event definition:
 */

/**********************************************************
 * Signal name mappings:
 */

/**********************************************************/

/** END_INPUT_DEFINITION **********************************************/

/**********************************************************
 * Generating unpacking code...
 */

//
// Generating code for: DUMMY
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for DUMMY.
 *
 * Do not edit - automatically generated.
 */

// DUMMY()
#if !PACKER_CODE
# define DECLARED_UNPACK_DUMMY
class DUMMY
#else//PACKER_CODE
# define DECLARED_PACKER_DUMMY
class PACKER_DUMMY
#endif//PACKER_CODE

{
public:
  // UINT32 no NOENCODE;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(DUMMY);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for DUMMY.
 *
 * Do not edit - automatically generated.
 */

// DUMMY()
template<typename __data_src_t>
void DUMMY::__unpack(__data_src_t &__buffer)
{
  // UINT32 no NOENCODE;
  uint32  no;READ_FROM_BUFFER(10,uint32 ,no,0);
}
FORCE_IMPL_DATA_SRC_FCN(void,DUMMY::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for DUMMY.
 *
 * Do not edit - automatically generated.
 */

// DUMMY()
template<typename __data_src_t>
bool DUMMY::__match(__data_src_t &__buffer)
{
  // UINT32 no NOENCODE;
  uint32  no;
  MATCH_READ_FROM_BUFFER(10,uint32 ,no,1);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,DUMMY::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for DUMMY.
 *
 * Do not edit - automatically generated.
 */

// DUMMY()
template<typename __data_dest_t>
void PACKER_DUMMY::__packer(__data_dest_t &__buffer)
{
  // UINT32 no NOENCODE;
}
FORCE_IMPL_DATA_SRC_FCN(void,DUMMY::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: FEBEX_PADDING
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for FEBEX_PADDING.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_PADDING()
#if !PACKER_CODE
# define DECLARED_UNPACK_FEBEX_PADDING
class FEBEX_PADDING
#else//PACKER_CODE
# define DECLARED_PACKER_FEBEX_PADDING
class PACKER_FEBEX_PADDING
#endif//PACKER_CODE

{
public:
  // UINT32 pads_data NOENCODE
  // {
    //  0_11: counter;
    // 12_19: index;
    // 20_31: 0xadd;
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(FEBEX_PADDING);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for FEBEX_PADDING.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_PADDING()
template<typename __data_src_t>
void FEBEX_PADDING::__unpack(__data_src_t &__buffer)
{
  // UINT32 pads_data NOENCODE
  // {
    //  0_11: counter;
    // 12_19: index;
    // 20_31: 0xadd;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 counter : 12; // 0..11
      uint32 index : 8; // 12..19
      uint32 unnamed_20_31 : 12; // 20..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_20_31 : 12; // 20..31
      uint32 index : 8; // 12..19
      uint32 counter : 12; // 0..11
#endif
    };
    uint32  u32;
  } pads_data;
  READ_FROM_BUFFER_FULL(20,uint32 ,pads_data,pads_data.u32,2);
  CHECK_BITS_EQUAL(19,pads_data.unnamed_20_31,0xadd);
}
FORCE_IMPL_DATA_SRC_FCN(void,FEBEX_PADDING::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for FEBEX_PADDING.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_PADDING()
template<typename __data_src_t>
bool FEBEX_PADDING::__match(__data_src_t &__buffer)
{
  // UINT32 pads_data NOENCODE
  // {
    //  0_11: counter;
    // 12_19: index;
    // 20_31: 0xadd;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 counter : 12; // 0..11
      uint32 index : 8; // 12..19
      uint32 unnamed_20_31 : 12; // 20..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_20_31 : 12; // 20..31
      uint32 index : 8; // 12..19
      uint32 counter : 12; // 0..11
#endif
    };
    uint32  u32;
  } pads_data;
  MATCH_READ_FROM_BUFFER_FULL(20,uint32 ,pads_data,pads_data.u32,3);
  MATCH_BITS_EQUAL(19,pads_data.unnamed_20_31,0xadd);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,FEBEX_PADDING::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for FEBEX_PADDING.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_PADDING()
template<typename __data_dest_t>
void PACKER_FEBEX_PADDING::__packer(__data_dest_t &__buffer)
{
  // UINT32 pads_data NOENCODE
  // {
    //  0_11: counter;
    // 12_19: index;
    // 20_31: 0xadd;
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,FEBEX_PADDING::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: FEBEX_TRACES
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for FEBEX_TRACES.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_TRACES()
#if !PACKER_CODE
# define DECLARED_UNPACK_FEBEX_TRACES
class FEBEX_TRACES
#else//PACKER_CODE
# define DECLARED_PACKER_FEBEX_TRACES
class PACKER_FEBEX_TRACES
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA8 ftrigger);
  DATA8 ftrigger;
  // MEMBER(DATA8 fboard);
  DATA8 fboard;
  // MEMBER(DATA32 ftrig_time_hi);
  DATA32 ftrig_time_hi;
  // MEMBER(DATA32 ftrig_time_lo);
  DATA32 ftrig_time_lo;
  // MEMBER(DATA32 fts_hi[16] ZERO_SUPPRESS_MULTI(32));
  raw_array_multi_zero_suppress<DATA32,DATA32,16,32> fts_hi;
  // MEMBER(DATA32 fts_lo[16] ZERO_SUPPRESS_MULTI(32));
  raw_array_multi_zero_suppress<DATA32,DATA32,16,32> fts_lo;
  // MEMBER(DATA32 fen[16] ZERO_SUPPRESS_MULTI(32));
  raw_array_multi_zero_suppress<DATA32,DATA32,16,32> fen;
  // MEMBER(DATA32 flength[16] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,16> flength;
  // MEMBER(DATA16 ftrace[16][4000] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA16,DATA16,4000> ftrace[16];
  // UINT32 FF_header NOENCODE
  // {
    //  0_07: three_four;
    //  8_11: trigger_type;
    // 12_15: sfp;
    // 16_23: board_id;
    // 24_31: 255;
    // ENCODE(ftrigger,(value=trigger_type));
    // ENCODE(fboard,(value=board_id));
  // }
  // UINT32 febex_chan_size NOENCODE
  // {
    //  0_01: ignore;
    //  2_31: size;
  // }
  // UINT32 febex_half_time NOENCODE
  // {
    //  0_15: ext_time;
    // 16_31: other;
    // ENCODE(ftrig_time_hi,(value=ext_time));
  // }
  // UINT32 febex_event_time NOENCODE
  // {
    //  0_31: time;
    // ENCODE(ftrig_time_lo,(value=time));
  // }
  // UINT32 febex_flags NOENCODE
  // {
    //  0_15: hit_pattern;
    // 16_31: pile_flags;
  // }
  // UINT32 deadbeef NOENCODE
  // {
    //  0_31: 0xdeadbeef;
  // }
  // if((FF_header.trigger_type == 3))

  // else

    // list(0<=i<16)

      // UINT32 pulse_header NOENCODE
      // {
        //  0_07: 52;
        //  8_31: stuff;
      // }
      // UINT32 pulse_trace_size NOENCODE
      // {
        //  0_31: size;
      // }
      // UINT32 pulse_trace_header NOENCODE
      // {
        //  0_31: head;
      // }
      // UINT32 pulse_trace_trailer NOENCODE
      // {
        //  0_31: trailer;
      // }
    // list(0<=i<((febex_chan_size.size / 4) - 1))

      // UINT32 F0_header NOENCODE
      // {
        //  0_15: ext_chan_ts;
        // 16_23: ch_id;
        // 24_31: 240;
        // ENCODE(fts_hi[i],(value=ext_chan_ts));
      // }
      // UINT32 febex_chan_ts NOENCODE
      // {
        //  0_31: chan_ts;
        // ENCODE(fts_lo[i],(value=chan_ts));
      // }
      // UINT32 febex_chan_en NOENCODE
      // {
        //  0_23: chan_en;
        // 24_29: cf;
        //    30: pileup;
        //    31: overflow;
        // ENCODE(fen[F0_header.ch_id],(value=chan_en));
      // }
      // UINT32 future_use NOENCODE
      // {
        //  0_31: future;
      // }
    // list(0<=i<16)

      // UINT32 header NOENCODE
      // {
        //  0_07: 52;
        //  8_23: other;
        // 24_31: ch_id;
      // }
      // UINT32 tracesize NOENCODE
      // {
        //  0_31: size;
      // }
      // UINT32 tracehead NOENCODE
      // {
        //  0_23: other;
        // 24_31: head;
      // }
      // ENCODE(flength[header.ch_id],(value=((tracesize.size / 2) - 4)));

      // list(0<=j<((tracesize.size / 4) - 2))

        // UINT32 channel_trace NOENCODE
        // {
          //  0_13: data1;
          // 14_15: stuff1;
          // 16_29: data2;
          // 30_31: stuff2;
          // ENCODE(ftrace[header.ch_id][((2 * j) + 0)],(value=data1));
          // ENCODE(ftrace[header.ch_id][((2 * j) + 1)],(value=data2));
        // }
      // UINT32 trace_trailer NOENCODE
      // {
        //  0_23: notused;
        // 24_31: id = RANGE(176,191);
      // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(FEBEX_TRACES);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for FEBEX_TRACES.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_TRACES()
template<typename __data_src_t>
void FEBEX_TRACES::__unpack(__data_src_t &__buffer)
{
  // MEMBER(DATA8 ftrigger);
  // MEMBER(DATA8 fboard);
  // MEMBER(DATA32 ftrig_time_hi);
  // MEMBER(DATA32 ftrig_time_lo);
  // MEMBER(DATA32 fts_hi[16] ZERO_SUPPRESS_MULTI(32));
  // MEMBER(DATA32 fts_lo[16] ZERO_SUPPRESS_MULTI(32));
  // MEMBER(DATA32 fen[16] ZERO_SUPPRESS_MULTI(32));
  // MEMBER(DATA32 flength[16] ZERO_SUPPRESS);
  // MEMBER(DATA16 ftrace[16][4000] ZERO_SUPPRESS);
  // UINT32 FF_header NOENCODE
  // {
    //  0_07: three_four;
    //  8_11: trigger_type;
    // 12_15: sfp;
    // 16_23: board_id;
    // 24_31: 255;
    // ENCODE(ftrigger,(value=trigger_type));
    // ENCODE(fboard,(value=board_id));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 three_four : 8; // 0..7
      uint32 trigger_type : 4; // 8..11
      uint32 sfp : 4; // 12..15
      uint32 board_id : 8; // 16..23
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 board_id : 8; // 16..23
      uint32 sfp : 4; // 12..15
      uint32 trigger_type : 4; // 8..11
      uint32 three_four : 8; // 0..7
#endif
    };
    uint32  u32;
  } FF_header;
  READ_FROM_BUFFER_FULL(43,uint32 ,FF_header,FF_header.u32,4);
  CHECK_BITS_EQUAL(40,FF_header.unnamed_24_31,255);
  {
    {
      ftrigger.value = FF_header.trigger_type;
    }
    {
      fboard.value = FF_header.board_id;
    }
  }
  // UINT32 febex_chan_size NOENCODE
  // {
    //  0_01: ignore;
    //  2_31: size;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 ignore : 2; // 0..1
      uint32 size : 30; // 2..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 size : 30; // 2..31
      uint32 ignore : 2; // 0..1
#endif
    };
    uint32  u32;
  } febex_chan_size;
  READ_FROM_BUFFER_FULL(48,uint32 ,febex_chan_size,febex_chan_size.u32,5);
  // UINT32 febex_half_time NOENCODE
  // {
    //  0_15: ext_time;
    // 16_31: other;
    // ENCODE(ftrig_time_hi,(value=ext_time));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 ext_time : 16; // 0..15
      uint32 other : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 other : 16; // 16..31
      uint32 ext_time : 16; // 0..15
#endif
    };
    uint32  u32;
  } febex_half_time;
  READ_FROM_BUFFER_FULL(54,uint32 ,febex_half_time,febex_half_time.u32,6);
  {
    ftrig_time_hi.value = febex_half_time.ext_time;
  }
  // UINT32 febex_event_time NOENCODE
  // {
    //  0_31: time;
    // ENCODE(ftrig_time_lo,(value=time));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 time : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 time : 32; // 0..31
#endif
    };
    uint32  u32;
  } febex_event_time;
  READ_FROM_BUFFER_FULL(59,uint32 ,febex_event_time,febex_event_time.u32,7);
  {
    ftrig_time_lo.value = febex_event_time.time;
  }
  // UINT32 febex_flags NOENCODE
  // {
    //  0_15: hit_pattern;
    // 16_31: pile_flags;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 hit_pattern : 16; // 0..15
      uint32 pile_flags : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 pile_flags : 16; // 16..31
      uint32 hit_pattern : 16; // 0..15
#endif
    };
    uint32  u32;
  } febex_flags;
  READ_FROM_BUFFER_FULL(64,uint32 ,febex_flags,febex_flags.u32,8);
  // UINT32 deadbeef NOENCODE
  // {
    //  0_31: 0xdeadbeef;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
    };
    uint32  u32;
  } deadbeef;
  READ_FROM_BUFFER_FULL(68,uint32 ,deadbeef,deadbeef.u32,9);
  CHECK_BITS_EQUAL(67,deadbeef.unnamed_0_31,0xdeadbeef);
  // if((FF_header.trigger_type == 3))

  // else

  if ((FF_header.trigger_type == 3))
  {
    // list(0<=i<16)

    for (uint32 i = 0; i < (uint32) (16); ++i)
    {
      // UINT32 pulse_header NOENCODE
      // {
        //  0_07: 52;
        //  8_31: stuff;
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint32 unnamed_0_7 : 8; // 0..7
          uint32 stuff : 24; // 8..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint32 stuff : 24; // 8..31
          uint32 unnamed_0_7 : 8; // 0..7
#endif
        };
        uint32  u32;
      } pulse_header;
      READ_FROM_BUFFER_FULL(77,uint32 ,pulse_header,pulse_header.u32,10);
      CHECK_BITS_EQUAL(75,pulse_header.unnamed_0_7,52);
      // UINT32 pulse_trace_size NOENCODE
      // {
        //  0_31: size;
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint32 size : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint32 size : 32; // 0..31
#endif
        };
        uint32  u32;
      } pulse_trace_size;
      READ_FROM_BUFFER_FULL(81,uint32 ,pulse_trace_size,pulse_trace_size.u32,11);
      // UINT32 pulse_trace_header NOENCODE
      // {
        //  0_31: head;
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint32 head : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint32 head : 32; // 0..31
#endif
        };
        uint32  u32;
      } pulse_trace_header;
      READ_FROM_BUFFER_FULL(85,uint32 ,pulse_trace_header,pulse_trace_header.u32,12);
      // UINT32 pulse_trace_trailer NOENCODE
      // {
        //  0_31: trailer;
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint32 trailer : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint32 trailer : 32; // 0..31
#endif
        };
        uint32  u32;
      } pulse_trace_trailer;
      READ_FROM_BUFFER_FULL(89,uint32 ,pulse_trace_trailer,pulse_trace_trailer.u32,13);
    }
  }

  else
  {
    // list(0<=i<((febex_chan_size.size / 4) - 1))

    for (uint32 i = 0; i < (uint32) (((febex_chan_size.size / 4) - 1)); ++i)
    {
      // UINT32 F0_header NOENCODE
      // {
        //  0_15: ext_chan_ts;
        // 16_23: ch_id;
        // 24_31: 240;
        // ENCODE(fts_hi[i],(value=ext_chan_ts));
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint32 ext_chan_ts : 16; // 0..15
          uint32 ch_id : 8; // 16..23
          uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint32 unnamed_24_31 : 8; // 24..31
          uint32 ch_id : 8; // 16..23
          uint32 ext_chan_ts : 16; // 0..15
#endif
        };
        uint32  u32;
      } F0_header;
      READ_FROM_BUFFER_FULL(102,uint32 ,F0_header,F0_header.u32,14);
      CHECK_BITS_EQUAL(100,F0_header.unnamed_24_31,240);
      {
        typedef __typeof__(*(&(fts_hi))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = fts_hi.insert_index(101,i);
        __item.value = F0_header.ext_chan_ts;
      }
      // UINT32 febex_chan_ts NOENCODE
      // {
        //  0_31: chan_ts;
        // ENCODE(fts_lo[i],(value=chan_ts));
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint32 chan_ts : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint32 chan_ts : 32; // 0..31
#endif
        };
        uint32  u32;
      } febex_chan_ts;
      READ_FROM_BUFFER_FULL(107,uint32 ,febex_chan_ts,febex_chan_ts.u32,15);
      {
        typedef __typeof__(*(&(fts_lo))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = fts_lo.insert_index(106,i);
        __item.value = febex_chan_ts.chan_ts;
      }
      // UINT32 febex_chan_en NOENCODE
      // {
        //  0_23: chan_en;
        // 24_29: cf;
        //    30: pileup;
        //    31: overflow;
        // ENCODE(fen[F0_header.ch_id],(value=chan_en));
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint32 chan_en : 24; // 0..23
          uint32 cf : 6; // 24..29
          uint32 pileup : 1; // 30
          uint32 overflow : 1; // 31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint32 overflow : 1; // 31
          uint32 pileup : 1; // 30
          uint32 cf : 6; // 24..29
          uint32 chan_en : 24; // 0..23
#endif
        };
        uint32  u32;
      } febex_chan_en;
      READ_FROM_BUFFER_FULL(115,uint32 ,febex_chan_en,febex_chan_en.u32,16);
      {
        typedef __typeof__(*(&(fen))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = fen.insert_index(114,F0_header.ch_id);
        __item.value = febex_chan_en.chan_en;
      }
      // UINT32 future_use NOENCODE
      // {
        //  0_31: future;
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint32 future : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint32 future : 32; // 0..31
#endif
        };
        uint32  u32;
      } future_use;
      READ_FROM_BUFFER_FULL(119,uint32 ,future_use,future_use.u32,17);
    }
    // list(0<=i<16)

    for (uint32 i = 0; i < (uint32) (16); ++i)
    {
      // UINT32 header NOENCODE
      // {
        //  0_07: 52;
        //  8_23: other;
        // 24_31: ch_id;
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint32 unnamed_0_7 : 8; // 0..7
          uint32 other : 16; // 8..23
          uint32 ch_id : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint32 ch_id : 8; // 24..31
          uint32 other : 16; // 8..23
          uint32 unnamed_0_7 : 8; // 0..7
#endif
        };
        uint32  u32;
      } header;
      READ_FROM_BUFFER_FULL(128,uint32 ,header,header.u32,18);
      CHECK_BITS_EQUAL(125,header.unnamed_0_7,52);
      // UINT32 tracesize NOENCODE
      // {
        //  0_31: size;
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint32 size : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint32 size : 32; // 0..31
#endif
        };
        uint32  u32;
      } tracesize;
      READ_FROM_BUFFER_FULL(132,uint32 ,tracesize,tracesize.u32,19);
      // UINT32 tracehead NOENCODE
      // {
        //  0_23: other;
        // 24_31: head;
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint32 other : 24; // 0..23
          uint32 head : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint32 head : 8; // 24..31
          uint32 other : 24; // 0..23
#endif
        };
        uint32  u32;
      } tracehead;
      READ_FROM_BUFFER_FULL(137,uint32 ,tracehead,tracehead.u32,20);
      // ENCODE(flength[header.ch_id],(value=((tracesize.size / 2) - 4)));

      {
        typedef __typeof__(*(&(flength))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = flength.insert_index(138,header.ch_id);
        __item.value = ((tracesize.size / 2) - 4);
      }
      // list(0<=j<((tracesize.size / 4) - 2))

      for (uint32 j = 0; j < (uint32) (((tracesize.size / 4) - 2)); ++j)
      {
        // UINT32 channel_trace NOENCODE
        // {
          //  0_13: data1;
          // 14_15: stuff1;
          // 16_29: data2;
          // 30_31: stuff2;
          // ENCODE(ftrace[header.ch_id][((2 * j) + 0)],(value=data1));
          // ENCODE(ftrace[header.ch_id][((2 * j) + 1)],(value=data2));
        // }
        union
        {
          struct
          {
#if __BYTE_ORDER == __LITTLE_ENDIAN
            uint32 data1 : 14; // 0..13
            uint32 stuff1 : 2; // 14..15
            uint32 data2 : 14; // 16..29
            uint32 stuff2 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
            uint32 stuff2 : 2; // 30..31
            uint32 data2 : 14; // 16..29
            uint32 stuff1 : 2; // 14..15
            uint32 data1 : 14; // 0..13
#endif
          };
          uint32  u32;
        } channel_trace;
        READ_FROM_BUFFER_FULL(150,uint32 ,channel_trace,channel_trace.u32,21);
        {
          {
            typedef __typeof__(*(&(ftrace[header.ch_id]))) __array_t;
            typedef typename __array_t::item_t __item_t;
            __item_t &__item = ftrace[header.ch_id].insert_index(148,((2 * j) + 0));
            __item.value = channel_trace.data1;
          }
          {
            typedef __typeof__(*(&(ftrace[header.ch_id]))) __array_t;
            typedef typename __array_t::item_t __item_t;
            __item_t &__item = ftrace[header.ch_id].insert_index(149,((2 * j) + 1));
            __item.value = channel_trace.data2;
          }
        }
      }
      // UINT32 trace_trailer NOENCODE
      // {
        //  0_23: notused;
        // 24_31: id = RANGE(176,191);
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint32 notused : 24; // 0..23
          uint32 id : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint32 id : 8; // 24..31
          uint32 notused : 24; // 0..23
#endif
        };
        uint32  u32;
      } trace_trailer;
      READ_FROM_BUFFER_FULL(156,uint32 ,trace_trailer,trace_trailer.u32,22);
      CHECK_BITS_RANGE(155,trace_trailer.id,176,191);
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,FEBEX_TRACES::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for FEBEX_TRACES.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_TRACES()
template<typename __data_src_t>
bool FEBEX_TRACES::__match(__data_src_t &__buffer)
{
  // MEMBER(DATA8 ftrigger);
  // MEMBER(DATA8 fboard);
  // MEMBER(DATA32 ftrig_time_hi);
  // MEMBER(DATA32 ftrig_time_lo);
  // MEMBER(DATA32 fts_hi[16] ZERO_SUPPRESS_MULTI(32));
  // MEMBER(DATA32 fts_lo[16] ZERO_SUPPRESS_MULTI(32));
  // MEMBER(DATA32 fen[16] ZERO_SUPPRESS_MULTI(32));
  // MEMBER(DATA32 flength[16] ZERO_SUPPRESS);
  // MEMBER(DATA16 ftrace[16][4000] ZERO_SUPPRESS);
  // UINT32 FF_header NOENCODE
  // {
    //  0_07: three_four;
    //  8_11: trigger_type;
    // 12_15: sfp;
    // 16_23: board_id;
    // 24_31: 255;
    // ENCODE(ftrigger,(value=trigger_type));
    // ENCODE(fboard,(value=board_id));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 three_four : 8; // 0..7
      uint32 trigger_type : 4; // 8..11
      uint32 sfp : 4; // 12..15
      uint32 board_id : 8; // 16..23
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 board_id : 8; // 16..23
      uint32 sfp : 4; // 12..15
      uint32 trigger_type : 4; // 8..11
      uint32 three_four : 8; // 0..7
#endif
    };
    uint32  u32;
  } FF_header;
  MATCH_READ_FROM_BUFFER_FULL(43,uint32 ,FF_header,FF_header.u32,23);
  MATCH_BITS_EQUAL(40,FF_header.unnamed_24_31,255);
  {
  }
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,FEBEX_TRACES::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for FEBEX_TRACES.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_TRACES()
template<typename __data_dest_t>
void PACKER_FEBEX_TRACES::__packer(__data_dest_t &__buffer)
{
  // MEMBER(DATA8 ftrigger);
  // MEMBER(DATA8 fboard);
  // MEMBER(DATA32 ftrig_time_hi);
  // MEMBER(DATA32 ftrig_time_lo);
  // MEMBER(DATA32 fts_hi[16] ZERO_SUPPRESS_MULTI(32));
  // MEMBER(DATA32 fts_lo[16] ZERO_SUPPRESS_MULTI(32));
  // MEMBER(DATA32 fen[16] ZERO_SUPPRESS_MULTI(32));
  // MEMBER(DATA32 flength[16] ZERO_SUPPRESS);
  // MEMBER(DATA16 ftrace[16][4000] ZERO_SUPPRESS);
  // UINT32 FF_header NOENCODE
  // {
    //  0_07: three_four;
    //  8_11: trigger_type;
    // 12_15: sfp;
    // 16_23: board_id;
    // 24_31: 255;
    // ENCODE(ftrigger,(value=trigger_type));
    // ENCODE(fboard,(value=board_id));
  // }
  // UINT32 febex_chan_size NOENCODE
  // {
    //  0_01: ignore;
    //  2_31: size;
  // }
  // UINT32 febex_half_time NOENCODE
  // {
    //  0_15: ext_time;
    // 16_31: other;
    // ENCODE(ftrig_time_hi,(value=ext_time));
  // }
  // UINT32 febex_event_time NOENCODE
  // {
    //  0_31: time;
    // ENCODE(ftrig_time_lo,(value=time));
  // }
  // UINT32 febex_flags NOENCODE
  // {
    //  0_15: hit_pattern;
    // 16_31: pile_flags;
  // }
  // UINT32 deadbeef NOENCODE
  // {
    //  0_31: 0xdeadbeef;
  // }
  // if((FF_header.trigger_type == 3))

  // else

  if ((FF_header.trigger_type == 3))
  {
    // list(0<=i<16)

    {
      // UINT32 pulse_header NOENCODE
      // {
        //  0_07: 52;
        //  8_31: stuff;
      // }
      // UINT32 pulse_trace_size NOENCODE
      // {
        //  0_31: size;
      // }
      // UINT32 pulse_trace_header NOENCODE
      // {
        //  0_31: head;
      // }
      // UINT32 pulse_trace_trailer NOENCODE
      // {
        //  0_31: trailer;
      // }
    }
  }

  else
  {
    // list(0<=i<((febex_chan_size.size / 4) - 1))

    {
      // UINT32 F0_header NOENCODE
      // {
        //  0_15: ext_chan_ts;
        // 16_23: ch_id;
        // 24_31: 240;
        // ENCODE(fts_hi[i],(value=ext_chan_ts));
      // }
      // UINT32 febex_chan_ts NOENCODE
      // {
        //  0_31: chan_ts;
        // ENCODE(fts_lo[i],(value=chan_ts));
      // }
      // UINT32 febex_chan_en NOENCODE
      // {
        //  0_23: chan_en;
        // 24_29: cf;
        //    30: pileup;
        //    31: overflow;
        // ENCODE(fen[F0_header.ch_id],(value=chan_en));
      // }
      // UINT32 future_use NOENCODE
      // {
        //  0_31: future;
      // }
    }
    // list(0<=i<16)

    {
      // UINT32 header NOENCODE
      // {
        //  0_07: 52;
        //  8_23: other;
        // 24_31: ch_id;
      // }
      // UINT32 tracesize NOENCODE
      // {
        //  0_31: size;
      // }
      // UINT32 tracehead NOENCODE
      // {
        //  0_23: other;
        // 24_31: head;
      // }
      // ENCODE(flength[header.ch_id],(value=((tracesize.size / 2) - 4)));

      // list(0<=j<((tracesize.size / 4) - 2))

      {
        // UINT32 channel_trace NOENCODE
        // {
          //  0_13: data1;
          // 14_15: stuff1;
          // 16_29: data2;
          // 30_31: stuff2;
          // ENCODE(ftrace[header.ch_id][((2 * j) + 0)],(value=data1));
          // ENCODE(ftrace[header.ch_id][((2 * j) + 1)],(value=data2));
        // }
      }
      // UINT32 trace_trailer NOENCODE
      // {
        //  0_23: notused;
        // 24_31: id = RANGE(176,191);
      // }
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,FEBEX_TRACES::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: TIMESTAMP_WHITERABBIT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TIMESTAMP_WHITERABBIT.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT(id)
#if !PACKER_CODE
# define DECLARED_UNPACK_TIMESTAMP_WHITERABBIT
class TIMESTAMP_WHITERABBIT
#else//PACKER_CODE
# define DECLARED_PACKER_TIMESTAMP_WHITERABBIT
class PACKER_TIMESTAMP_WHITERABBIT
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA12 subsystem_id);
  DATA12 subsystem_id;
  // MEMBER(DATA16 t1);
  DATA16 t1;
  // MEMBER(DATA16 t2);
  DATA16 t2;
  // MEMBER(DATA16 t3);
  DATA16 t3;
  // MEMBER(DATA16 t4);
  DATA16 t4;
  // UINT32 header NOENCODE
  // {
    //  0_11: id = MATCH(id);
    // 12_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  // UINT32 d1 NOENCODE
  // {
    //  0_15: t1;
    // 16_31: 0x3e1;
    // ENCODE(t1,(value=t1));
  // }
  // UINT32 d2 NOENCODE
  // {
    //  0_15: t2;
    // 16_31: 0x4e1;
    // ENCODE(t2,(value=t2));
  // }
  // UINT32 d3 NOENCODE
  // {
    //  0_15: t3;
    // 16_31: 0x5e1;
    // ENCODE(t3,(value=t3));
  // }
  // UINT32 d4 NOENCODE
  // {
    //  0_15: t4;
    // 16_31: 0x6e1;
    // ENCODE(t4,(value=t4));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 id);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 id);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TIMESTAMP_WHITERABBIT);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TIMESTAMP_WHITERABBIT.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT(id)
template<typename __data_src_t>
void TIMESTAMP_WHITERABBIT::__unpack(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA12 subsystem_id);
  // MEMBER(DATA16 t1);
  // MEMBER(DATA16 t2);
  // MEMBER(DATA16 t3);
  // MEMBER(DATA16 t4);
  // UINT32 header NOENCODE
  // {
    //  0_11: id = MATCH(id);
    // 12_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 id : 12; // 0..11
      uint32 unnamed_12_15 : 4; // 12..15
      uint32 error_bit : 1; // 16
      uint32 unnamed_17_31 : 15; // 17..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_17_31 : 15; // 17..31
      uint32 error_bit : 1; // 16
      uint32 unnamed_12_15 : 4; // 12..15
      uint32 id : 12; // 0..11
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(175,uint32 ,header,header.u32,24);
  CHECK_BITS_EQUAL(170,header.id,id);
  CHECK_BITS_EQUAL(171,header.unnamed_12_15,0);
  CHECK_BITS_EQUAL(173,header.unnamed_17_31,0);
  {
    subsystem_id.value = header.id;
  }
  // UINT32 d1 NOENCODE
  // {
    //  0_15: t1;
    // 16_31: 0x3e1;
    // ENCODE(t1,(value=t1));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t1 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t1 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d1;
  READ_FROM_BUFFER_FULL(181,uint32 ,d1,d1.u32,25);
  CHECK_BITS_EQUAL(179,d1.unnamed_16_31,0x3e1);
  {
    t1.value = d1.t1;
  }
  // UINT32 d2 NOENCODE
  // {
    //  0_15: t2;
    // 16_31: 0x4e1;
    // ENCODE(t2,(value=t2));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t2 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t2 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d2;
  READ_FROM_BUFFER_FULL(187,uint32 ,d2,d2.u32,26);
  CHECK_BITS_EQUAL(185,d2.unnamed_16_31,0x4e1);
  {
    t2.value = d2.t2;
  }
  // UINT32 d3 NOENCODE
  // {
    //  0_15: t3;
    // 16_31: 0x5e1;
    // ENCODE(t3,(value=t3));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t3 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t3 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d3;
  READ_FROM_BUFFER_FULL(193,uint32 ,d3,d3.u32,27);
  CHECK_BITS_EQUAL(191,d3.unnamed_16_31,0x5e1);
  {
    t3.value = d3.t3;
  }
  // UINT32 d4 NOENCODE
  // {
    //  0_15: t4;
    // 16_31: 0x6e1;
    // ENCODE(t4,(value=t4));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t4 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t4 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d4;
  READ_FROM_BUFFER_FULL(199,uint32 ,d4,d4.u32,28);
  CHECK_BITS_EQUAL(197,d4.unnamed_16_31,0x6e1);
  {
    t4.value = d4.t4;
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TIMESTAMP_WHITERABBIT::__unpack,uint32 id);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TIMESTAMP_WHITERABBIT.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT(id)
template<typename __data_src_t>
bool TIMESTAMP_WHITERABBIT::__match(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA12 subsystem_id);
  // MEMBER(DATA16 t1);
  // MEMBER(DATA16 t2);
  // MEMBER(DATA16 t3);
  // MEMBER(DATA16 t4);
  // UINT32 header NOENCODE
  // {
    //  0_11: id = MATCH(id);
    // 12_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 id : 12; // 0..11
      uint32 unnamed_12_15 : 4; // 12..15
      uint32 error_bit : 1; // 16
      uint32 unnamed_17_31 : 15; // 17..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_17_31 : 15; // 17..31
      uint32 error_bit : 1; // 16
      uint32 unnamed_12_15 : 4; // 12..15
      uint32 id : 12; // 0..11
#endif
    };
    uint32  u32;
  } header;
  MATCH_READ_FROM_BUFFER_FULL(175,uint32 ,header,header.u32,29);
  MATCH_BITS_EQUAL(170,header.id,id);
  MATCH_BITS_EQUAL(171,header.unnamed_12_15,0);
  MATCH_BITS_EQUAL(173,header.unnamed_17_31,0);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,TIMESTAMP_WHITERABBIT::__match,uint32 id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TIMESTAMP_WHITERABBIT.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT(id)
template<typename __data_dest_t>
void PACKER_TIMESTAMP_WHITERABBIT::__packer(__data_dest_t &__buffer,uint32 id)
{
  // MEMBER(DATA12 subsystem_id);
  // MEMBER(DATA16 t1);
  // MEMBER(DATA16 t2);
  // MEMBER(DATA16 t3);
  // MEMBER(DATA16 t4);
  // UINT32 header NOENCODE
  // {
    //  0_11: id = MATCH(id);
    // 12_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  // UINT32 d1 NOENCODE
  // {
    //  0_15: t1;
    // 16_31: 0x3e1;
    // ENCODE(t1,(value=t1));
  // }
  // UINT32 d2 NOENCODE
  // {
    //  0_15: t2;
    // 16_31: 0x4e1;
    // ENCODE(t2,(value=t2));
  // }
  // UINT32 d3 NOENCODE
  // {
    //  0_15: t3;
    // 16_31: 0x5e1;
    // ENCODE(t3,(value=t3));
  // }
  // UINT32 d4 NOENCODE
  // {
    //  0_15: t4;
    // 16_31: 0x6e1;
    // ENCODE(t4,(value=t4));
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TIMESTAMP_WHITERABBIT::__packer,uint32 id);

/** END_PACKER ********************************************************/

//
// Generating code for: TIMESTAMP_WHITERABBIT_EXTENDED
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TIMESTAMP_WHITERABBIT_EXTENDED.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT_EXTENDED(id)
#if !PACKER_CODE
# define DECLARED_UNPACK_TIMESTAMP_WHITERABBIT_EXTENDED
class TIMESTAMP_WHITERABBIT_EXTENDED
#else//PACKER_CODE
# define DECLARED_PACKER_TIMESTAMP_WHITERABBIT_EXTENDED
class PACKER_TIMESTAMP_WHITERABBIT_EXTENDED
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA16 subsystem_id);
  DATA16 subsystem_id;
  // MEMBER(DATA16 t1);
  DATA16 t1;
  // MEMBER(DATA16 t2);
  DATA16 t2;
  // MEMBER(DATA16 t3);
  DATA16 t3;
  // MEMBER(DATA16 t4);
  DATA16 t4;
  // UINT32 header NOENCODE
  // {
    //  0_12: id = MATCH(id);
    // 13_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  // UINT32 d1 NOENCODE
  // {
    //  0_15: t1;
    // 16_31: 0x3e1;
    // ENCODE(t1,(value=t1));
  // }
  // UINT32 d2 NOENCODE
  // {
    //  0_15: t2;
    // 16_31: 0x4e1;
    // ENCODE(t2,(value=t2));
  // }
  // UINT32 d3 NOENCODE
  // {
    //  0_15: t3;
    // 16_31: 0x5e1;
    // ENCODE(t3,(value=t3));
  // }
  // UINT32 d4 NOENCODE
  // {
    //  0_15: t4;
    // 16_31: 0x6e1;
    // ENCODE(t4,(value=t4));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 id);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 id);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TIMESTAMP_WHITERABBIT_EXTENDED);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TIMESTAMP_WHITERABBIT_EXTENDED.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT_EXTENDED(id)
template<typename __data_src_t>
void TIMESTAMP_WHITERABBIT_EXTENDED::__unpack(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA16 subsystem_id);
  // MEMBER(DATA16 t1);
  // MEMBER(DATA16 t2);
  // MEMBER(DATA16 t3);
  // MEMBER(DATA16 t4);
  // UINT32 header NOENCODE
  // {
    //  0_12: id = MATCH(id);
    // 13_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 id : 13; // 0..12
      uint32 unnamed_13_15 : 3; // 13..15
      uint32 error_bit : 1; // 16
      uint32 unnamed_17_31 : 15; // 17..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_17_31 : 15; // 17..31
      uint32 error_bit : 1; // 16
      uint32 unnamed_13_15 : 3; // 13..15
      uint32 id : 13; // 0..12
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(216,uint32 ,header,header.u32,30);
  CHECK_BITS_EQUAL(211,header.id,id);
  CHECK_BITS_EQUAL(212,header.unnamed_13_15,0);
  CHECK_BITS_EQUAL(214,header.unnamed_17_31,0);
  {
    subsystem_id.value = header.id;
  }
  // UINT32 d1 NOENCODE
  // {
    //  0_15: t1;
    // 16_31: 0x3e1;
    // ENCODE(t1,(value=t1));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t1 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t1 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d1;
  READ_FROM_BUFFER_FULL(222,uint32 ,d1,d1.u32,31);
  CHECK_BITS_EQUAL(220,d1.unnamed_16_31,0x3e1);
  {
    t1.value = d1.t1;
  }
  // UINT32 d2 NOENCODE
  // {
    //  0_15: t2;
    // 16_31: 0x4e1;
    // ENCODE(t2,(value=t2));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t2 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t2 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d2;
  READ_FROM_BUFFER_FULL(228,uint32 ,d2,d2.u32,32);
  CHECK_BITS_EQUAL(226,d2.unnamed_16_31,0x4e1);
  {
    t2.value = d2.t2;
  }
  // UINT32 d3 NOENCODE
  // {
    //  0_15: t3;
    // 16_31: 0x5e1;
    // ENCODE(t3,(value=t3));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t3 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t3 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d3;
  READ_FROM_BUFFER_FULL(234,uint32 ,d3,d3.u32,33);
  CHECK_BITS_EQUAL(232,d3.unnamed_16_31,0x5e1);
  {
    t3.value = d3.t3;
  }
  // UINT32 d4 NOENCODE
  // {
    //  0_15: t4;
    // 16_31: 0x6e1;
    // ENCODE(t4,(value=t4));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t4 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t4 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d4;
  READ_FROM_BUFFER_FULL(240,uint32 ,d4,d4.u32,34);
  CHECK_BITS_EQUAL(238,d4.unnamed_16_31,0x6e1);
  {
    t4.value = d4.t4;
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TIMESTAMP_WHITERABBIT_EXTENDED::__unpack,uint32 id);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TIMESTAMP_WHITERABBIT_EXTENDED.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT_EXTENDED(id)
template<typename __data_src_t>
bool TIMESTAMP_WHITERABBIT_EXTENDED::__match(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA16 subsystem_id);
  // MEMBER(DATA16 t1);
  // MEMBER(DATA16 t2);
  // MEMBER(DATA16 t3);
  // MEMBER(DATA16 t4);
  // UINT32 header NOENCODE
  // {
    //  0_12: id = MATCH(id);
    // 13_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 id : 13; // 0..12
      uint32 unnamed_13_15 : 3; // 13..15
      uint32 error_bit : 1; // 16
      uint32 unnamed_17_31 : 15; // 17..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_17_31 : 15; // 17..31
      uint32 error_bit : 1; // 16
      uint32 unnamed_13_15 : 3; // 13..15
      uint32 id : 13; // 0..12
#endif
    };
    uint32  u32;
  } header;
  MATCH_READ_FROM_BUFFER_FULL(216,uint32 ,header,header.u32,35);
  MATCH_BITS_EQUAL(211,header.id,id);
  MATCH_BITS_EQUAL(212,header.unnamed_13_15,0);
  MATCH_BITS_EQUAL(214,header.unnamed_17_31,0);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,TIMESTAMP_WHITERABBIT_EXTENDED::__match,uint32 id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TIMESTAMP_WHITERABBIT_EXTENDED.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT_EXTENDED(id)
template<typename __data_dest_t>
void PACKER_TIMESTAMP_WHITERABBIT_EXTENDED::__packer(__data_dest_t &__buffer,uint32 id)
{
  // MEMBER(DATA16 subsystem_id);
  // MEMBER(DATA16 t1);
  // MEMBER(DATA16 t2);
  // MEMBER(DATA16 t3);
  // MEMBER(DATA16 t4);
  // UINT32 header NOENCODE
  // {
    //  0_12: id = MATCH(id);
    // 13_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  // UINT32 d1 NOENCODE
  // {
    //  0_15: t1;
    // 16_31: 0x3e1;
    // ENCODE(t1,(value=t1));
  // }
  // UINT32 d2 NOENCODE
  // {
    //  0_15: t2;
    // 16_31: 0x4e1;
    // ENCODE(t2,(value=t2));
  // }
  // UINT32 d3 NOENCODE
  // {
    //  0_15: t3;
    // 16_31: 0x5e1;
    // ENCODE(t3,(value=t3));
  // }
  // UINT32 d4 NOENCODE
  // {
    //  0_15: t4;
    // 16_31: 0x6e1;
    // ENCODE(t4,(value=t4));
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TIMESTAMP_WHITERABBIT_EXTENDED::__packer,uint32 id);

/** END_PACKER ********************************************************/

//
// Generating code for: WR_MULTI
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for WR_MULTI.
 *
 * Do not edit - automatically generated.
 */

// WR_MULTI()
#if !PACKER_CODE
# define DECLARED_UNPACK_WR_MULTI
class WR_MULTI
#else//PACKER_CODE
# define DECLARED_PACKER_WR_MULTI
class PACKER_WR_MULTI
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA32 time_hi);
  DATA32 time_hi;
  // MEMBER(DATA32 time_lo);
  DATA32 time_lo;
  // UINT32 hi NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_hi,(value=time));
  // }
  // UINT32 lo NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_lo,(value=time));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(WR_MULTI);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for WR_MULTI.
 *
 * Do not edit - automatically generated.
 */

// WR_MULTI()
template<typename __data_src_t>
void WR_MULTI::__unpack(__data_src_t &__buffer)
{
  // MEMBER(DATA32 time_hi);
  // MEMBER(DATA32 time_lo);
  // UINT32 hi NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_hi,(value=time));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 time : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 time : 32; // 0..31
#endif
    };
    uint32  u32;
  } hi;
  READ_FROM_BUFFER_FULL(251,uint32 ,hi,hi.u32,36);
  {
    time_hi.value = hi.time;
  }
  // UINT32 lo NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_lo,(value=time));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 time : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 time : 32; // 0..31
#endif
    };
    uint32  u32;
  } lo;
  READ_FROM_BUFFER_FULL(256,uint32 ,lo,lo.u32,37);
  {
    time_lo.value = lo.time;
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,WR_MULTI::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for WR_MULTI.
 *
 * Do not edit - automatically generated.
 */

// WR_MULTI()
template<typename __data_src_t>
bool WR_MULTI::__match(__data_src_t &__buffer)
{
  // MEMBER(DATA32 time_hi);
  // MEMBER(DATA32 time_lo);
  // UINT32 hi NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_hi,(value=time));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 time : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 time : 32; // 0..31
#endif
    };
    uint32  u32;
  } hi;
  MATCH_READ_FROM_BUFFER_FULL(251,uint32 ,hi,hi.u32,38);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,WR_MULTI::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for WR_MULTI.
 *
 * Do not edit - automatically generated.
 */

// WR_MULTI()
template<typename __data_dest_t>
void PACKER_WR_MULTI::__packer(__data_dest_t &__buffer)
{
  // MEMBER(DATA32 time_hi);
  // MEMBER(DATA32 time_lo);
  // UINT32 hi NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_hi,(value=time));
  // }
  // UINT32 lo NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_lo,(value=time));
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,WR_MULTI::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: febex_subev
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for febex_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(febex_subev)
#if !PACKER_CODE
# define DECLARED_UNPACK_febex_subev
class febex_subev
#else//PACKER_CODE
# define DECLARED_PACKER_febex_subev
class PACKER_febex_subev
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // if(0)

    // wr = TIMESTAMP_WHITERABBIT(id=0x400);
    SINGLE(TIMESTAMP_WHITERABBIT,wr);
  // select several

    // padding = FEBEX_PADDING();
  SINGLE(FEBEX_PADDING,padding);
  // data = FEBEX_TRACES();
  SINGLE(FEBEX_TRACES,data);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(febex_subev);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for febex_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(febex_subev)
template<typename __data_src_t>
void febex_subev::__unpack(__data_src_t &__buffer)
{
  // if(0)

  if (0)
  {
    // wr = TIMESTAMP_WHITERABBIT(id=0x400);
    UNPACK_DECL(263,TIMESTAMP_WHITERABBIT,wr,/*id*/0x400);
  }
  // select several

    // padding = FEBEX_PADDING();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: FEBEX_PADDING padding: (s32) => (0xfff00000,0xadd00000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(268,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(267,spurious_match_abort_loop_0,FEBEX_PADDING);
        UNPACK_DECL(267,FEBEX_PADDING,padding);
        break;
    }
  }
  spurious_match_abort_loop_0:;
  // data = FEBEX_TRACES();
  UNPACK_DECL(269,FEBEX_TRACES,data);
}
FORCE_IMPL_DATA_SRC_FCN(void,febex_subev::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for febex_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(febex_subev)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for febex_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(febex_subev)
template<typename __data_dest_t>
void PACKER_febex_subev::__packer(__data_dest_t &__buffer)
{
  // if(0)

  if (0)
  {
    // wr = TIMESTAMP_WHITERABBIT(id=0x400);
    PACK_DECL(263,TIMESTAMP_WHITERABBIT,wr,/*id*/0x400);
  }
  // select several

    // padding = FEBEX_PADDING();
  {
    PACK_DECL(267,FEBEX_PADDING,padding);
  }
  // data = FEBEX_TRACES();
  PACK_DECL(269,FEBEX_TRACES,data);
}
FORCE_IMPL_DATA_SRC_FCN(void,febex_subev::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for EVENT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for EVENT.
 *
 * Do not edit - automatically generated.
 */

// EVENT
class unpack_event : public unpack_event_base
{
public:
  // trace = febex_subev(procid=60);
  // ignore_unknown_subevent;
SINGLE(febex_subev,trace);
public:
#ifndef __PSDC__
  bitsone<2> __visited;
  void __clear_visited() { __visited.clear(); }
  bool ignore_unknown_subevent() { return true; }
#endif//!__PSDC__

public:
#ifndef __PSDC__
template<typename __data_src_t>
  int __unpack_subevent(subevent_header *__header,__data_src_t &__buffer);
  int __revoke_subevent(subevent_header *__header);
  // void __clean_event();

  STRUCT_FCNS_DECL(unpack_event);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for EVENT.
 *
 * Do not edit - automatically generated.
 */

// EVENT
template<typename __data_src_t>
int unpack_event::__unpack_subevent(subevent_header *__header,__data_src_t &__buffer)
  // trace = febex_subev(procid=60);
  // ignore_unknown_subevent;
{
  int __match_no = 0;
  MATCH_SUBEVENT_DECL(278,__match_no,1,((VES10_1_procid==60)),trace);
  if (!__match_no) return 0;
  switch (__match_no)
  {
    case 1:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(278,febex_subev,trace,0);
      UNPACK_SUBEVENT_DECL(278,0,febex_subev,trace);
      break;
  }
  return 0;
}
FORCE_IMPL_DATA_SRC_FCN_HDR(int,unpack_event::__unpack_subevent);

/** END_UNPACKER ******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for EVENT.
 *
 * Do not edit - automatically generated.
 */

// EVENT
  // trace = febex_subev(procid=60);
  // ignore_unknown_subevent;
{
}

/** END_PACKER ********************************************************/


/** BEGIN_REVOKE *******************************************************
 *
 * Event revoker for EVENT.
 *
 * Do not edit - automatically generated.
 */

// EVENT
int unpack_event::__revoke_subevent(subevent_header *__header)
  // trace = febex_subev(procid=60);
  // ignore_unknown_subevent;
{
  int __match_no = 0;
  MATCH_SUBEVENT_DECL(278,__match_no,1,((VES10_1_procid==60)),trace);
  if (!__match_no) return 0;
  switch (__match_no)
  {
    case 1:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(278,febex_subev,trace,0);
      REVOKE_SUBEVENT_DECL(278,0,febex_subev,trace);
      break;
  }
  return 0;
}

/** END_REVOKE ********************************************************/


/** BEGIN_SUBEVENT_NAMES ***********************************************
 *
 * Mappings of names for [incl|excl] name lookup.
 *
 * Do not edit - automatically generated.
 */

{ "trace", "procid=60" },

/** END_SUBEVENT_NAMES ************************************************/

//
// Generating code for EVENT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for EVENT.
 *
 * Do not edit - automatically generated.
 */

// STICKY_EVENT
class unpack_sticky_event : public unpack_sticky_event_base
{
public:
public:
#ifndef __PSDC__
  void __clear_visited() { }
  bool ignore_unknown_subevent() { return false; }
#endif//!__PSDC__

public:
#ifndef __PSDC__
template<typename __data_src_t>
  int __unpack_subevent(subevent_header *__header,__data_src_t &__buffer);
  int __revoke_subevent(subevent_header *__header);
  // void __clean_event();

  STRUCT_FCNS_DECL(unpack_sticky_event);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for EVENT.
 *
 * Do not edit - automatically generated.
 */

// STICKY_EVENT
template<typename __data_src_t>
int unpack_sticky_event::__unpack_subevent(subevent_header *__header,__data_src_t &__buffer)
{
  int __match_no = 0;
  if (!__match_no) return 0;
  switch (__match_no)
  {
  }
  return 0;
}
FORCE_IMPL_DATA_SRC_FCN_HDR(int,unpack_sticky_event::__unpack_subevent);

/** END_UNPACKER ******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for EVENT.
 *
 * Do not edit - automatically generated.
 */

// STICKY_EVENT
{
}

/** END_PACKER ********************************************************/


/** BEGIN_REVOKE *******************************************************
 *
 * Event revoker for EVENT.
 *
 * Do not edit - automatically generated.
 */

// STICKY_EVENT
int unpack_sticky_event::__revoke_subevent(subevent_header *__header)
{
  int __match_no = 0;
  if (!__match_no) return 0;
  switch (__match_no)
  {
  }
  return 0;
}

/** END_REVOKE ********************************************************/


/** BEGIN_SUBEVENT_NAMES ***********************************************
 *
 * Mappings of names for [incl|excl] name lookup.
 *
 * Do not edit - automatically generated.
 */


/** END_SUBEVENT_NAMES ************************************************/


/** BEGIN_UNPACKER_DEFINES *********************************************
 *
 * Control
 *
 * Do not edit - automatically generated.
 */

#define STICKY_EVENT_IS_NONTRIVIAL  0


/** END_UNPACKER_DEFINES **********************************************/

/**********************************************************/
/**********************************************************
 * Generating event structure...
 */


/** BEGIN_EVENT_RAW_STRUCTURE ******************************************
 *
 * Event data structure.
 *
 * Do not edit - automatically generated.
 */

class raw_event : public raw_event_base
{
public:

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event);
#endif//!__PSDC__
} ;

/** END_EVENT_RAW_STRUCTURE *******************************************/


/** BEGIN_EVENT_CAL_STRUCTURE ******************************************
 *
 * Event data structure.
 *
 * Do not edit - automatically generated.
 */

class cal_event : public cal_event_base
{
public:

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(cal_event);
#endif//!__PSDC__
} ;

/** END_EVENT_CAL_STRUCTURE *******************************************/


/** BEGIN_EVENT_RAW_STRUCTURE ******************************************
 *
 * Event data structure.
 *
 * Do not edit - automatically generated.
 */

class raw_sticky : public raw_sticky_base
{
public:

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_sticky);
#endif//!__PSDC__
} ;

/** END_EVENT_RAW_STRUCTURE *******************************************/


/** BEGIN_EVENT_DATA_MAPPING *******************************************
 *
 * Event data mapping.
 *
 * Do not edit - automatically generated.
 */

// The order in this file does not matter.
// This information parsed once and not treated eventwise,
// it is used to initialize a structure.


/** END_EVENT_DATA_MAPPING ********************************************/


/** BEGIN_EVENT_DATA_MAPPING *******************************************
 *
 * Event data mapping.
 *
 * Do not edit - automatically generated.
 */

// The order in this file does not matter.
// This information parsed once and not treated eventwise,
// it is used to initialize a structure.


/** END_EVENT_DATA_MAPPING ********************************************/

/**********************************************************/

/** BEGIN_LOCATIONS ****************************************************
 *
 * File and line locations from the parsed specification files.
 *
 * Do not edit - automatically generated.
 */

// It's left to the compiler to only store one copy of each
// unique string.

location spec_locations[] =
{ 
  { 2, 1, "gen_lisa/reparse.uce" },
  { 3, 1, "<built-in>" },
  { 4, 1, "<command-line>" },
  { 5, 1, "/usr/include/stdc-predef.h" },
  { 6, 1, "<command-line>" },
  { 7, 1, "gen_lisa/reparse.uce" },
  { 8, 12, "gen_lisa/reparse.uce" },
};

/** END_LOCATIONS *****************************************************/


/** BEGIN_ACCOUNT_IDS **************************************************
 *
 * Structure and identifier for raw data items.
 *
 * Do not edit - automatically generated.
 */

account_id _account_ids[] =
{ 
  { 0, "DUMMY", "no" },
  { 1, "DUMMY", "no" },
  { 2, "FEBEX_PADDING", "pads_data" },
  { 3, "FEBEX_PADDING", "pads_data" },
  { 4, "FEBEX_TRACES", "FF_header" },
  { 5, "FEBEX_TRACES", "febex_chan_size" },
  { 6, "FEBEX_TRACES", "febex_half_time" },
  { 7, "FEBEX_TRACES", "febex_event_time" },
  { 8, "FEBEX_TRACES", "febex_flags" },
  { 9, "FEBEX_TRACES", "deadbeef" },
  { 10, "FEBEX_TRACES", "pulse_header" },
  { 11, "FEBEX_TRACES", "pulse_trace_size" },
  { 12, "FEBEX_TRACES", "pulse_trace_header" },
  { 13, "FEBEX_TRACES", "pulse_trace_trailer" },
  { 14, "FEBEX_TRACES", "F0_header" },
  { 15, "FEBEX_TRACES", "febex_chan_ts" },
  { 16, "FEBEX_TRACES", "febex_chan_en" },
  { 17, "FEBEX_TRACES", "future_use" },
  { 18, "FEBEX_TRACES", "header" },
  { 19, "FEBEX_TRACES", "tracesize" },
  { 20, "FEBEX_TRACES", "tracehead" },
  { 21, "FEBEX_TRACES", "channel_trace" },
  { 22, "FEBEX_TRACES", "trace_trailer" },
  { 23, "FEBEX_TRACES", "FF_header" },
  { 24, "TIMESTAMP_WHITERABBIT", "header" },
  { 25, "TIMESTAMP_WHITERABBIT", "d1" },
  { 26, "TIMESTAMP_WHITERABBIT", "d2" },
  { 27, "TIMESTAMP_WHITERABBIT", "d3" },
  { 28, "TIMESTAMP_WHITERABBIT", "d4" },
  { 29, "TIMESTAMP_WHITERABBIT", "header" },
  { 30, "TIMESTAMP_WHITERABBIT_EXTENDED", "header" },
  { 31, "TIMESTAMP_WHITERABBIT_EXTENDED", "d1" },
  { 32, "TIMESTAMP_WHITERABBIT_EXTENDED", "d2" },
  { 33, "TIMESTAMP_WHITERABBIT_EXTENDED", "d3" },
  { 34, "TIMESTAMP_WHITERABBIT_EXTENDED", "d4" },
  { 35, "TIMESTAMP_WHITERABBIT_EXTENDED", "header" },
  { 36, "WR_MULTI", "hi" },
  { 37, "WR_MULTI", "lo" },
  { 38, "WR_MULTI", "hi" },
};

#define NUM_ACCOUNT_IDS  39

/** END_ACCOUNT_IDS ***************************************************/

