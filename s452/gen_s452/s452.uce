
/** BEGIN_INPUT_DEFINITION *********************************************
 *
 * All specifications as seen by the parser.
 *
 * Do not edit - automatically generated.
 */

/**********************************************************
 * Dump of all structures:
 */

AIDA()
{
  MEMBER(DATA8 module[13000] NO_INDEX_LIST);
  MEMBER(DATA8 channel[13000] NO_INDEX_LIST);
  MEMBER(DATA8 info[13000] NO_INDEX_LIST);
  MEMBER(DATA16 adc[13000] NO_INDEX_LIST);
  MEMBER(DATA32 ts_low[13000] NO_INDEX_LIST);
  MEMBER(DATA32 ts_med[13000] NO_INDEX_LIST);
  MEMBER(DATA32 ts_high[13000] NO_INDEX_LIST);
  select several
  {
    mod[0] = AIDA_MODULE(module_id=0,module=module,channel=channel,info=info,
                         adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    mod[1] = AIDA_MODULE(module_id=1,module=module,channel=channel,info=info,
                         adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    mod[2] = AIDA_MODULE(module_id=2,module=module,channel=channel,info=info,
                         adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    mod[3] = AIDA_MODULE(module_id=3,module=module,channel=channel,info=info,
                         adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    mod[4] = AIDA_MODULE(module_id=4,module=module,channel=channel,info=info,
                         adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    mod[5] = AIDA_MODULE(module_id=5,module=module,channel=channel,info=info,
                         adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    mod[6] = AIDA_MODULE(module_id=6,module=module,channel=channel,info=info,
                         adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    mod[7] = AIDA_MODULE(module_id=7,module=module,channel=channel,info=info,
                         adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    mod[8] = AIDA_MODULE(module_id=8,module=module,channel=channel,info=info,
                         adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    mod[9] = AIDA_MODULE(module_id=9,module=module,channel=channel,info=info,
                         adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    mod[10] = AIDA_MODULE(module_id=10,module=module,channel=channel,
                          info=info,adc=adc,ts_low=ts_low,ts_med=ts_med,
                          ts_high=ts_high);
    mod[11] = AIDA_MODULE(module_id=11,module=module,channel=channel,
                          info=info,adc=adc,ts_low=ts_low,ts_med=ts_med,
                          ts_high=ts_high);
  }
}

AIDA_ADC(module_id,module,channel,info,adc,ts_low,ts_med,ts_high)
{
  MEMBER(DATA8 module[13000] NO_INDEX_LIST);
  MEMBER(DATA8 channel[13000] NO_INDEX_LIST);
  MEMBER(DATA8 info[13000] NO_INDEX_LIST);
  MEMBER(DATA16 adc[13000] NO_INDEX_LIST);
  MEMBER(DATA32 ts_low[13000] NO_INDEX_LIST);
  MEMBER(DATA32 ts_med[13000] NO_INDEX_LIST);
  MEMBER(DATA32 ts_high[13000] NO_INDEX_LIST);
  UINT32 wordA NOENCODE
  {
     0_15: adc_value;
    16_21: channel_id = RANGE(0,63);
    22_27: module_id = MATCH(module_id);
       28: adc_range;
       29: 0;
    30_31: 3;
  }
  UINT32 wordB NOENCODE
  {
     0_27: ts;
    28_31: 0;
  }
  ENCODE(module APPEND_LIST,(value=static_cast<uint8_t>(module_id)));

  ENCODE(adc APPEND_LIST,(value=wordA.adc_value));

  ENCODE(channel APPEND_LIST,(value=wordA.channel_id));

  ENCODE(ts_low APPEND_LIST,(value=wordB.ts));

  ENCODE(ts_med APPEND_LIST,(value=0));

  ENCODE(ts_high APPEND_LIST,(value=0));

  ENCODE(info APPEND_LIST,(value=255));

}

AIDA_INFO(module_id,module,channel,info,adc,ts_low,ts_med,ts_high)
{
  MEMBER(DATA8 module[13000] NO_INDEX_LIST);
  MEMBER(DATA8 channel[13000] NO_INDEX_LIST);
  MEMBER(DATA8 info[13000] NO_INDEX_LIST);
  MEMBER(DATA16 adc[13000] NO_INDEX_LIST);
  MEMBER(DATA32 ts_low[13000] NO_INDEX_LIST);
  MEMBER(DATA32 ts_med[13000] NO_INDEX_LIST);
  MEMBER(DATA32 ts_high[13000] NO_INDEX_LIST);
  UINT32 wordA NOENCODE
  {
     0_19: info_field;
    20_23: info_code = RANGE(2,15);
    24_29: module_id = MATCH(module_id);
    30_31: 2;
  }
  UINT32 wordB NOENCODE
  {
     0_27: info_time;
    28_31: 0;
  }
  ENCODE(module APPEND_LIST,(value=static_cast<uint8_t>(module_id)));

  ENCODE(info APPEND_LIST,(value=wordA.info_code));

  ENCODE(ts_low APPEND_LIST,(value=wordB.info_time));

  ENCODE(channel APPEND_LIST,(value=255));

  if((((wordA.info_code == 2) || (wordA.info_code == 4)) || (wordA.info_code == 7)))
  {
    ENCODE(ts_med APPEND_LIST,(value=wordA.info_field));

    ENCODE(ts_high APPEND_LIST,(value=0));

    ENCODE(adc APPEND_LIST,(value=0));

  }
  if(((wordA.info_code == 5) || (wordA.info_code == 8)))
  {
    ENCODE(ts_high APPEND_LIST,(value=wordA.info_field));

    ENCODE(ts_med APPEND_LIST,(value=0));

    ENCODE(adc APPEND_LIST,(value=0));

  }
  if((wordA.info_code == 6))
  {
    ENCODE(adc APPEND_LIST,(value=0));

    ENCODE(ts_med APPEND_LIST,(value=wordA.info_field));

    ENCODE(ts_high APPEND_LIST,(value=0));

  }
}

AIDA_MODULE(module_id,module,channel,info,adc,ts_low,ts_med,ts_high)
{
  MEMBER(DATA8 module[13000] NO_INDEX_LIST);
  MEMBER(DATA8 channel[13000] NO_INDEX_LIST);
  MEMBER(DATA8 info[13000] NO_INDEX_LIST);
  MEMBER(DATA16 adc[13000] NO_INDEX_LIST);
  MEMBER(DATA32 ts_low[13000] NO_INDEX_LIST);
  MEMBER(DATA32 ts_med[13000] NO_INDEX_LIST);
  MEMBER(DATA32 ts_high[13000] NO_INDEX_LIST);
  select several
  {
    i = AIDA_INFO(module_id=module_id,module=module,channel=channel,info=info,
                  adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    d = AIDA_ADC(module_id=module_id,module=module,channel=channel,info=info,
                 adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
  }
}

DUMMY()
{
  UINT32 no NOENCODE;
}

external EXT_AIDA()
;

external EXT_FATIMA_TAMEX()
;

external EXT_FATIMA_VME()
;

external EXT_GERMANIUM()
;

FATIMA_QDC()
{
  ;
}

FATIMA_SCALER()
{
  MEMBER(DATA32 scalers[16] ZERO_SUPPRESS_LIST);
  UINT32 header NOENCODE
  {
     0_31: h = CHECK(0x7a001000);
  }
  list(0<=index<16)
  {
    UINT32 ch_data NOENCODE;
    ENCODE(scalers[index],(value=ch_data));

  }
  UINT32 trailer NOENCODE
  {
     0_31: t = CHECK(0x7c000000);
  }
}

FATIMA_TAMEX()
{
  select several
  {
    dummy = DUMMY();
  }
}

FATIMA_TDC()
{
  ;
}

FATIMA_VME()
{
  select optional
  {
    scaler = FATIMA_SCALER();
  }
  select several
  {
    dummy = DUMMY();
  }
}

FRS()
{
  select several
  {
    dummy = DUMMY();
  }
}

FRS_FRS()
{
  MEMBER(DATA32 scalers[32] ZERO_SUPPRESS_LIST);
  UINT32 no NOENCODE;
  if(((no & 0xffff0000) == 0x04400000))
  {
    list(0<=index<32)
    {
      UINT32 ch_data NOENCODE;
      ENCODE(scalers[index],(value=ch_data));

    }
  }
}

FRS_MAIN()
{
  MEMBER(DATA32 scalers[32] ZERO_SUPPRESS_LIST);
  UINT32 no NOENCODE;
  if((no == 0xbabababa))
  {
    UINT32 sc NOENCODE;
    if(((sc & 0xffff0000) == 0x0c800000))
    {
      list(0<=index<32)
      {
        UINT32 ch_data NOENCODE;
        ENCODE(scalers[index],(value=ch_data));

      }
    }
  }
}

TIMESTAMP_WHITERABBIT(id)
{
  MEMBER(DATA12 subsystem_id);
  MEMBER(DATA16 t1);
  MEMBER(DATA16 t2);
  MEMBER(DATA16 t3);
  MEMBER(DATA16 t4);
  UINT32 header NOENCODE
  {
     0_11: id = MATCH(id);
    12_15: 0;
       16: error_bit;
    17_31: 0;
    ENCODE(subsystem_id,(value=id));
  }
  UINT32 d1 NOENCODE
  {
     0_15: t1;
    16_31: 0x3e1;
    ENCODE(t1,(value=t1));
  }
  UINT32 d2 NOENCODE
  {
     0_15: t2;
    16_31: 0x4e1;
    ENCODE(t2,(value=t2));
  }
  UINT32 d3 NOENCODE
  {
     0_15: t3;
    16_31: 0x5e1;
    ENCODE(t3,(value=t3));
  }
  UINT32 d4 NOENCODE
  {
     0_15: t4;
    16_31: 0x6e1;
    ENCODE(t4,(value=t4));
  }
}

TIMESTAMP_WHITERABBIT_EXTENDED(id)
{
  MEMBER(DATA16 subsystem_id);
  MEMBER(DATA16 t1);
  MEMBER(DATA16 t2);
  MEMBER(DATA16 t3);
  MEMBER(DATA16 t4);
  UINT32 header NOENCODE
  {
     0_12: id = MATCH(id);
    13_15: 0;
       16: error_bit;
    17_31: 0;
    ENCODE(subsystem_id,(value=id));
  }
  UINT32 d1 NOENCODE
  {
     0_15: t1;
    16_31: 0x3e1;
    ENCODE(t1,(value=t1));
  }
  UINT32 d2 NOENCODE
  {
     0_15: t2;
    16_31: 0x4e1;
    ENCODE(t2,(value=t2));
  }
  UINT32 d3 NOENCODE
  {
     0_15: t3;
    16_31: 0x5e1;
    ENCODE(t3,(value=t3));
  }
  UINT32 d4 NOENCODE
  {
     0_15: t4;
    16_31: 0x6e1;
    ENCODE(t4,(value=t4));
  }
}

TRLOII_TPAT(id)
{
  MEMBER(DATA32 n);
  MEMBER(DATA32 tpat[170] NO_INDEX_LIST);
  MEMBER(DATA8 trig[170] NO_INDEX_LIST);
  MEMBER(DATA32 ts_lo[170] NO_INDEX_LIST);
  MEMBER(DATA32 ts_hi[170] NO_INDEX_LIST);
  UINT32 header NOENCODE
  {
     0_11: uint32_num;
    12_23: event_num;
    24_31: id = MATCH(id);
    ENCODE(n,(value=(uint32_num / 3)));
  }
  list(0<=index<(header.uint32_num / 3))
  {
    UINT32 time_lo NOENCODE
    {
       0_31: t;
      ENCODE(ts_lo APPEND_LIST,(value=t));
    }
    UINT32 time_hi NOENCODE
    {
       0_30: t;
         31: overflow;
      ENCODE(ts_hi APPEND_LIST,(value=t));
    }
    UINT32 trigger NOENCODE
    {
       0_23: tpat;
      24_27: encoded;
      28_31: lec;
      ENCODE(tpat APPEND_LIST,(value=tpat));
      ENCODE(trig APPEND_LIST,(value=encoded));
    }
  }
}

WR_MULTI()
{
  MEMBER(DATA32 time_hi);
  MEMBER(DATA32 time_lo);
  UINT32 hi NOENCODE
  {
     0_31: time;
    ENCODE(time_hi,(value=time));
  }
  UINT32 lo NOENCODE
  {
     0_31: time;
    ENCODE(time_lo,(value=time));
  }
}

SUBEVENT(aida_subev)
{
  ts = TIMESTAMP_WHITERABBIT(id=0x700);
  external data = EXT_AIDA();
}

SUBEVENT(fatima_tamex_subev)
{
  ts = TIMESTAMP_WHITERABBIT_EXTENDED(id=0x1600);
  external data = EXT_FATIMA_TAMEX();
}

SUBEVENT(fatima_vme_subev)
{
  ts = TIMESTAMP_WHITERABBIT_EXTENDED(id=0x1500);
  external data = EXT_FATIMA_VME();
}

SUBEVENT(frs_frs_subev)
{
  select several
  {
    subev = FRS_FRS();
  }
}

SUBEVENT(frs_main_subev)
{
  select several
  {
    subev = FRS_MAIN();
  }
}

SUBEVENT(frs_subev1)
{
  ts = TIMESTAMP_WHITERABBIT(id=0x100);
  subev = FRS();
}

SUBEVENT(frs_subev4)
{
  ts = TIMESTAMP_WHITERABBIT(id=0x100);
  subev = FRS();
}

SUBEVENT(frs_subev6)
{
  ts = TIMESTAMP_WHITERABBIT(id=0x100);
  subev = FRS();
}

SUBEVENT(frs_tpat_subev)
{
  dummy = DUMMY();
  tpat = TRLOII_TPAT(id=207);
}

SUBEVENT(germanium_subev)
{
  ts = TIMESTAMP_WHITERABBIT(id=0x400);
  external data = EXT_GERMANIUM();
}

SUBEVENT(plastic_subev)
{
  ts = TIMESTAMP_WHITERABBIT(id=0x500);
}

/**********************************************************
 * The event definition:
 */

EVENT
{
  germanium = germanium_subev(type=10,subtype=1,procid=60,control=20,
                              subcrate=0);
  fatima_vme = fatima_vme_subev(type=10,subtype=1,procid=70,control=20,
                                subcrate=0);
  fatima_tamex = fatima_tamex_subev(type=10,subtype=1,procid=75,control=20,
                                    subcrate=0);
  aida = aida_subev(type=10,subtype=1,procid=90,control=37,subcrate=0);
  frs_main = frs_main_subev(type=12,subtype=1,procid=10,control=20,
                            subcrate=0);
  frs_tpat = frs_tpat_subev(type=36,subtype=0xe10,procid=10,control=20,
                            subcrate=0);
  frs_frs = frs_frs_subev(type=12,subtype=1,procid=30,control=20,
                          subcrate=0);
  ignore_unknown_subevent;
}

/**********************************************************
 * The sticky_event definition:
 */

/**********************************************************
 * Signal name mappings:
 */

/**********************************************************/

/** END_INPUT_DEFINITION **********************************************/

/**********************************************************
 * Generating unpacking code...
 */

//
// Generating code for: AIDA
//
//
// Generating code for: AIDA_MODULE
//
//
// Generating code for: AIDA_INFO
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for AIDA_INFO.
 *
 * Do not edit - automatically generated.
 */

// AIDA_INFO(module_id,module,channel,info,adc,ts_low,ts_med,ts_high)
#if !PACKER_CODE
# define DECLARED_UNPACK_AIDA_INFO
class AIDA_INFO
#else//PACKER_CODE
# define DECLARED_PACKER_AIDA_INFO
class PACKER_AIDA_INFO
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA8 module[13000] NO_INDEX_LIST);
  // MEMBER(DATA8 channel[13000] NO_INDEX_LIST);
  // MEMBER(DATA8 info[13000] NO_INDEX_LIST);
  // MEMBER(DATA16 adc[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_low[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_med[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_high[13000] NO_INDEX_LIST);
  // UINT32 wordA NOENCODE
  // {
    //  0_19: info_field;
    // 20_23: info_code = RANGE(2,15);
    // 24_29: module_id = MATCH(module_id);
    // 30_31: 2;
  // }
  // UINT32 wordB NOENCODE
  // {
    //  0_27: info_time;
    // 28_31: 0;
  // }
  // ENCODE(module APPEND_LIST,(value=static_cast<uint8_t>(module_id)));

  // ENCODE(info APPEND_LIST,(value=wordA.info_code));

  // ENCODE(ts_low APPEND_LIST,(value=wordB.info_time));

  // ENCODE(channel APPEND_LIST,(value=255));

  // if((((wordA.info_code == 2) || (wordA.info_code == 4)) || (wordA.info_code == 7)))

    // ENCODE(ts_med APPEND_LIST,(value=wordA.info_field));

    // ENCODE(ts_high APPEND_LIST,(value=0));

    // ENCODE(adc APPEND_LIST,(value=0));

  // if(((wordA.info_code == 5) || (wordA.info_code == 8)))

    // ENCODE(ts_high APPEND_LIST,(value=wordA.info_field));

    // ENCODE(ts_med APPEND_LIST,(value=0));

    // ENCODE(adc APPEND_LIST,(value=0));

  // if((wordA.info_code == 6))

    // ENCODE(adc APPEND_LIST,(value=0));

    // ENCODE(ts_med APPEND_LIST,(value=wordA.info_field));

    // ENCODE(ts_high APPEND_LIST,(value=0));


public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 module_id,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &module
                                      ,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &channel
                                      ,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &info
                                      ,raw_list_ii_zero_suppress<DATA16,DATA16,13000> &adc
                                      ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_low
                                      ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_med
                                      ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_high);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 module_id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 module_id,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &module
                                       ,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &channel
                                       ,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &info
                                       ,raw_list_ii_zero_suppress<DATA16,DATA16,13000> &adc
                                       ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_low
                                       ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_med
                                       ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_high);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(AIDA_INFO);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for AIDA_INFO.
 *
 * Do not edit - automatically generated.
 */

// AIDA_INFO(module_id,module,channel,info,adc,ts_low,ts_med,ts_high)
template<typename __data_src_t>
void AIDA_INFO::__unpack(__data_src_t &__buffer,uint32 module_id,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &module
                                               ,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &channel
                                               ,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &info
                                               ,raw_list_ii_zero_suppress<DATA16,DATA16,13000> &adc
                                               ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_low
                                               ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_med
                                               ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_high)
{
  // MEMBER(DATA8 module[13000] NO_INDEX_LIST);
  // MEMBER(DATA8 channel[13000] NO_INDEX_LIST);
  // MEMBER(DATA8 info[13000] NO_INDEX_LIST);
  // MEMBER(DATA16 adc[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_low[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_med[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_high[13000] NO_INDEX_LIST);
  // UINT32 wordA NOENCODE
  // {
    //  0_19: info_field;
    // 20_23: info_code = RANGE(2,15);
    // 24_29: module_id = MATCH(module_id);
    // 30_31: 2;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 info_field : 20; // 0..19
      uint32 info_code : 4; // 20..23
      uint32 module_id : 6; // 24..29
      uint32 unnamed_30_31 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_30_31 : 2; // 30..31
      uint32 module_id : 6; // 24..29
      uint32 info_code : 4; // 20..23
      uint32 info_field : 20; // 0..19
#endif
    };
    uint32  u32;
  } wordA;
  READ_FROM_BUFFER_FULL(54,uint32 ,wordA,wordA.u32,0);
  CHECK_BITS_RANGE(51,wordA.info_code,2,15);
  CHECK_BITS_EQUAL(52,wordA.module_id,module_id);
  CHECK_BITS_EQUAL(53,wordA.unnamed_30_31,2);
  // UINT32 wordB NOENCODE
  // {
    //  0_27: info_time;
    // 28_31: 0;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 info_time : 28; // 0..27
      uint32 unnamed_28_31 : 4; // 28..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_28_31 : 4; // 28..31
      uint32 info_time : 28; // 0..27
#endif
    };
    uint32  u32;
  } wordB;
  READ_FROM_BUFFER_FULL(60,uint32 ,wordB,wordB.u32,1);
  CHECK_BITS_EQUAL(59,wordB.unnamed_28_31,0);
  // ENCODE(module APPEND_LIST,(value=static_cast<uint8_t>(module_id)));

  {
    typedef __typeof__(*(&(module))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = module.append_item(62);
    __item.value = static_cast<uint8_t>(module_id);
  }
  // ENCODE(info APPEND_LIST,(value=wordA.info_code));

  {
    typedef __typeof__(*(&(info))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = info.append_item(63);
    __item.value = wordA.info_code;
  }
  // ENCODE(ts_low APPEND_LIST,(value=wordB.info_time));

  {
    typedef __typeof__(*(&(ts_low))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = ts_low.append_item(64);
    __item.value = wordB.info_time;
  }
  // ENCODE(channel APPEND_LIST,(value=255));

  {
    typedef __typeof__(*(&(channel))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = channel.append_item(66);
    __item.value = 255;
  }
  // if((((wordA.info_code == 2) || (wordA.info_code == 4)) || (wordA.info_code == 7)))

  if ((((wordA.info_code == 2) || (wordA.info_code == 4)) || (wordA.info_code == 7)))
  {
    // ENCODE(ts_med APPEND_LIST,(value=wordA.info_field));

    {
      typedef __typeof__(*(&(ts_med))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = ts_med.append_item(71);
      __item.value = wordA.info_field;
    }
    // ENCODE(ts_high APPEND_LIST,(value=0));

    {
      typedef __typeof__(*(&(ts_high))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = ts_high.append_item(72);
      __item.value = 0;
    }
    // ENCODE(adc APPEND_LIST,(value=0));

    {
      typedef __typeof__(*(&(adc))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = adc.append_item(73);
      __item.value = 0;
    }
  }
  // if(((wordA.info_code == 5) || (wordA.info_code == 8)))

  if (((wordA.info_code == 5) || (wordA.info_code == 8)))
  {
    // ENCODE(ts_high APPEND_LIST,(value=wordA.info_field));

    {
      typedef __typeof__(*(&(ts_high))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = ts_high.append_item(79);
      __item.value = wordA.info_field;
    }
    // ENCODE(ts_med APPEND_LIST,(value=0));

    {
      typedef __typeof__(*(&(ts_med))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = ts_med.append_item(80);
      __item.value = 0;
    }
    // ENCODE(adc APPEND_LIST,(value=0));

    {
      typedef __typeof__(*(&(adc))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = adc.append_item(81);
      __item.value = 0;
    }
  }
  // if((wordA.info_code == 6))

  if ((wordA.info_code == 6))
  {
    // ENCODE(adc APPEND_LIST,(value=0));

    {
      typedef __typeof__(*(&(adc))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = adc.append_item(87);
      __item.value = 0;
    }
    // ENCODE(ts_med APPEND_LIST,(value=wordA.info_field));

    {
      typedef __typeof__(*(&(ts_med))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = ts_med.append_item(88);
      __item.value = wordA.info_field;
    }
    // ENCODE(ts_high APPEND_LIST,(value=0));

    {
      typedef __typeof__(*(&(ts_high))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = ts_high.append_item(89);
      __item.value = 0;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,AIDA_INFO::__unpack,uint32 module_id,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &module
                                                    ,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &channel
                                                    ,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &info
                                                    ,raw_list_ii_zero_suppress<DATA16,DATA16,13000> &adc
                                                    ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_low
                                                    ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_med
                                                    ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_high);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for AIDA_INFO.
 *
 * Do not edit - automatically generated.
 */

// AIDA_INFO(module_id,module,channel,info,adc,ts_low,ts_med,ts_high)
template<typename __data_src_t>
bool AIDA_INFO::__match(__data_src_t &__buffer,uint32 module_id)
{
  // MEMBER(DATA8 module[13000] NO_INDEX_LIST);
  // MEMBER(DATA8 channel[13000] NO_INDEX_LIST);
  // MEMBER(DATA8 info[13000] NO_INDEX_LIST);
  // MEMBER(DATA16 adc[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_low[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_med[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_high[13000] NO_INDEX_LIST);
  // UINT32 wordA NOENCODE
  // {
    //  0_19: info_field;
    // 20_23: info_code = RANGE(2,15);
    // 24_29: module_id = MATCH(module_id);
    // 30_31: 2;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 info_field : 20; // 0..19
      uint32 info_code : 4; // 20..23
      uint32 module_id : 6; // 24..29
      uint32 unnamed_30_31 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_30_31 : 2; // 30..31
      uint32 module_id : 6; // 24..29
      uint32 info_code : 4; // 20..23
      uint32 info_field : 20; // 0..19
#endif
    };
    uint32  u32;
  } wordA;
  MATCH_READ_FROM_BUFFER_FULL(54,uint32 ,wordA,wordA.u32,2);
  MATCH_BITS_RANGE(51,wordA.info_code,2,15);
  MATCH_BITS_EQUAL(52,wordA.module_id,module_id);
  MATCH_BITS_EQUAL(53,wordA.unnamed_30_31,2);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,AIDA_INFO::__match,uint32 module_id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for AIDA_INFO.
 *
 * Do not edit - automatically generated.
 */

// AIDA_INFO(module_id,module,channel,info,adc,ts_low,ts_med,ts_high)
template<typename __data_dest_t>
void PACKER_AIDA_INFO::__packer(__data_dest_t &__buffer,uint32 module_id
                                                       ,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &module
                                                       ,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &channel
                                                       ,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &info
                                                       ,raw_list_ii_zero_suppress<DATA16,DATA16,13000> &adc
                                                       ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_low
                                                       ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_med
                                                       ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_high)
{
  // MEMBER(DATA8 module[13000] NO_INDEX_LIST);
  // MEMBER(DATA8 channel[13000] NO_INDEX_LIST);
  // MEMBER(DATA8 info[13000] NO_INDEX_LIST);
  // MEMBER(DATA16 adc[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_low[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_med[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_high[13000] NO_INDEX_LIST);
  // UINT32 wordA NOENCODE
  // {
    //  0_19: info_field;
    // 20_23: info_code = RANGE(2,15);
    // 24_29: module_id = MATCH(module_id);
    // 30_31: 2;
  // }
  // UINT32 wordB NOENCODE
  // {
    //  0_27: info_time;
    // 28_31: 0;
  // }
  // ENCODE(module APPEND_LIST,(value=static_cast<uint8_t>(module_id)));

  // ENCODE(info APPEND_LIST,(value=wordA.info_code));

  // ENCODE(ts_low APPEND_LIST,(value=wordB.info_time));

  // ENCODE(channel APPEND_LIST,(value=255));

  // if((((wordA.info_code == 2) || (wordA.info_code == 4)) || (wordA.info_code == 7)))

  if ((((wordA.info_code == 2) || (wordA.info_code == 4)) || (wordA.info_code == 7)))
  {
    // ENCODE(ts_med APPEND_LIST,(value=wordA.info_field));

    // ENCODE(ts_high APPEND_LIST,(value=0));

    // ENCODE(adc APPEND_LIST,(value=0));

  }
  // if(((wordA.info_code == 5) || (wordA.info_code == 8)))

  if (((wordA.info_code == 5) || (wordA.info_code == 8)))
  {
    // ENCODE(ts_high APPEND_LIST,(value=wordA.info_field));

    // ENCODE(ts_med APPEND_LIST,(value=0));

    // ENCODE(adc APPEND_LIST,(value=0));

  }
  // if((wordA.info_code == 6))

  if ((wordA.info_code == 6))
  {
    // ENCODE(adc APPEND_LIST,(value=0));

    // ENCODE(ts_med APPEND_LIST,(value=wordA.info_field));

    // ENCODE(ts_high APPEND_LIST,(value=0));

  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,AIDA_INFO::__packer,uint32 module_id);

/** END_PACKER ********************************************************/

//
// Generating code for: AIDA_ADC
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for AIDA_ADC.
 *
 * Do not edit - automatically generated.
 */

// AIDA_ADC(module_id,module,channel,info,adc,ts_low,ts_med,ts_high)
#if !PACKER_CODE
# define DECLARED_UNPACK_AIDA_ADC
class AIDA_ADC
#else//PACKER_CODE
# define DECLARED_PACKER_AIDA_ADC
class PACKER_AIDA_ADC
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA8 module[13000] NO_INDEX_LIST);
  // MEMBER(DATA8 channel[13000] NO_INDEX_LIST);
  // MEMBER(DATA8 info[13000] NO_INDEX_LIST);
  // MEMBER(DATA16 adc[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_low[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_med[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_high[13000] NO_INDEX_LIST);
  // UINT32 wordA NOENCODE
  // {
    //  0_15: adc_value;
    // 16_21: channel_id = RANGE(0,63);
    // 22_27: module_id = MATCH(module_id);
    //    28: adc_range;
    //    29: 0;
    // 30_31: 3;
  // }
  // UINT32 wordB NOENCODE
  // {
    //  0_27: ts;
    // 28_31: 0;
  // }
  // ENCODE(module APPEND_LIST,(value=static_cast<uint8_t>(module_id)));

  // ENCODE(adc APPEND_LIST,(value=wordA.adc_value));

  // ENCODE(channel APPEND_LIST,(value=wordA.channel_id));

  // ENCODE(ts_low APPEND_LIST,(value=wordB.ts));

  // ENCODE(ts_med APPEND_LIST,(value=0));

  // ENCODE(ts_high APPEND_LIST,(value=0));

  // ENCODE(info APPEND_LIST,(value=255));


public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 module_id,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &module
                                      ,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &channel
                                      ,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &info
                                      ,raw_list_ii_zero_suppress<DATA16,DATA16,13000> &adc
                                      ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_low
                                      ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_med
                                      ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_high);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 module_id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 module_id,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &module
                                       ,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &channel
                                       ,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &info
                                       ,raw_list_ii_zero_suppress<DATA16,DATA16,13000> &adc
                                       ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_low
                                       ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_med
                                       ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_high);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(AIDA_ADC);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for AIDA_ADC.
 *
 * Do not edit - automatically generated.
 */

// AIDA_ADC(module_id,module,channel,info,adc,ts_low,ts_med,ts_high)
template<typename __data_src_t>
void AIDA_ADC::__unpack(__data_src_t &__buffer,uint32 module_id,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &module
                                              ,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &channel
                                              ,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &info
                                              ,raw_list_ii_zero_suppress<DATA16,DATA16,13000> &adc
                                              ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_low
                                              ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_med
                                              ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_high)
{
  // MEMBER(DATA8 module[13000] NO_INDEX_LIST);
  // MEMBER(DATA8 channel[13000] NO_INDEX_LIST);
  // MEMBER(DATA8 info[13000] NO_INDEX_LIST);
  // MEMBER(DATA16 adc[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_low[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_med[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_high[13000] NO_INDEX_LIST);
  // UINT32 wordA NOENCODE
  // {
    //  0_15: adc_value;
    // 16_21: channel_id = RANGE(0,63);
    // 22_27: module_id = MATCH(module_id);
    //    28: adc_range;
    //    29: 0;
    // 30_31: 3;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 adc_value : 16; // 0..15
      uint32 channel_id : 6; // 16..21
      uint32 module_id : 6; // 22..27
      uint32 adc_range : 1; // 28
      uint32 unnamed_29_29 : 1; // 29
      uint32 unnamed_30_31 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_30_31 : 2; // 30..31
      uint32 unnamed_29_29 : 1; // 29
      uint32 adc_range : 1; // 28
      uint32 module_id : 6; // 22..27
      uint32 channel_id : 6; // 16..21
      uint32 adc_value : 16; // 0..15
#endif
    };
    uint32  u32;
  } wordA;
  READ_FROM_BUFFER_FULL(106,uint32 ,wordA,wordA.u32,3);
  CHECK_BITS_RANGE_MAX(101,wordA.channel_id,63);
  CHECK_BITS_EQUAL(102,wordA.module_id,module_id);
  CHECK_BITS_EQUAL(104,wordA.unnamed_29_29,0);
  CHECK_BITS_EQUAL(105,wordA.unnamed_30_31,3);
  // UINT32 wordB NOENCODE
  // {
    //  0_27: ts;
    // 28_31: 0;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 ts : 28; // 0..27
      uint32 unnamed_28_31 : 4; // 28..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_28_31 : 4; // 28..31
      uint32 ts : 28; // 0..27
#endif
    };
    uint32  u32;
  } wordB;
  READ_FROM_BUFFER_FULL(112,uint32 ,wordB,wordB.u32,4);
  CHECK_BITS_EQUAL(111,wordB.unnamed_28_31,0);
  // ENCODE(module APPEND_LIST,(value=static_cast<uint8_t>(module_id)));

  {
    typedef __typeof__(*(&(module))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = module.append_item(114);
    __item.value = static_cast<uint8_t>(module_id);
  }
  // ENCODE(adc APPEND_LIST,(value=wordA.adc_value));

  {
    typedef __typeof__(*(&(adc))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = adc.append_item(115);
    __item.value = wordA.adc_value;
  }
  // ENCODE(channel APPEND_LIST,(value=wordA.channel_id));

  {
    typedef __typeof__(*(&(channel))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = channel.append_item(116);
    __item.value = wordA.channel_id;
  }
  // ENCODE(ts_low APPEND_LIST,(value=wordB.ts));

  {
    typedef __typeof__(*(&(ts_low))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = ts_low.append_item(117);
    __item.value = wordB.ts;
  }
  // ENCODE(ts_med APPEND_LIST,(value=0));

  {
    typedef __typeof__(*(&(ts_med))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = ts_med.append_item(118);
    __item.value = 0;
  }
  // ENCODE(ts_high APPEND_LIST,(value=0));

  {
    typedef __typeof__(*(&(ts_high))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = ts_high.append_item(119);
    __item.value = 0;
  }
  // ENCODE(info APPEND_LIST,(value=255));

  {
    typedef __typeof__(*(&(info))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = info.append_item(121);
    __item.value = 255;
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,AIDA_ADC::__unpack,uint32 module_id,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &module
                                                   ,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &channel
                                                   ,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &info
                                                   ,raw_list_ii_zero_suppress<DATA16,DATA16,13000> &adc
                                                   ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_low
                                                   ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_med
                                                   ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_high);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for AIDA_ADC.
 *
 * Do not edit - automatically generated.
 */

// AIDA_ADC(module_id,module,channel,info,adc,ts_low,ts_med,ts_high)
template<typename __data_src_t>
bool AIDA_ADC::__match(__data_src_t &__buffer,uint32 module_id)
{
  // MEMBER(DATA8 module[13000] NO_INDEX_LIST);
  // MEMBER(DATA8 channel[13000] NO_INDEX_LIST);
  // MEMBER(DATA8 info[13000] NO_INDEX_LIST);
  // MEMBER(DATA16 adc[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_low[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_med[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_high[13000] NO_INDEX_LIST);
  // UINT32 wordA NOENCODE
  // {
    //  0_15: adc_value;
    // 16_21: channel_id = RANGE(0,63);
    // 22_27: module_id = MATCH(module_id);
    //    28: adc_range;
    //    29: 0;
    // 30_31: 3;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 adc_value : 16; // 0..15
      uint32 channel_id : 6; // 16..21
      uint32 module_id : 6; // 22..27
      uint32 adc_range : 1; // 28
      uint32 unnamed_29_29 : 1; // 29
      uint32 unnamed_30_31 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_30_31 : 2; // 30..31
      uint32 unnamed_29_29 : 1; // 29
      uint32 adc_range : 1; // 28
      uint32 module_id : 6; // 22..27
      uint32 channel_id : 6; // 16..21
      uint32 adc_value : 16; // 0..15
#endif
    };
    uint32  u32;
  } wordA;
  MATCH_READ_FROM_BUFFER_FULL(106,uint32 ,wordA,wordA.u32,5);
  MATCH_BITS_RANGE_MAX(101,wordA.channel_id,63);
  MATCH_BITS_EQUAL(102,wordA.module_id,module_id);
  MATCH_BITS_EQUAL(104,wordA.unnamed_29_29,0);
  MATCH_BITS_EQUAL(105,wordA.unnamed_30_31,3);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,AIDA_ADC::__match,uint32 module_id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for AIDA_ADC.
 *
 * Do not edit - automatically generated.
 */

// AIDA_ADC(module_id,module,channel,info,adc,ts_low,ts_med,ts_high)
template<typename __data_dest_t>
void PACKER_AIDA_ADC::__packer(__data_dest_t &__buffer,uint32 module_id,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &module
                                                      ,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &channel
                                                      ,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &info
                                                      ,raw_list_ii_zero_suppress<DATA16,DATA16,13000> &adc
                                                      ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_low
                                                      ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_med
                                                      ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_high)
{
  // MEMBER(DATA8 module[13000] NO_INDEX_LIST);
  // MEMBER(DATA8 channel[13000] NO_INDEX_LIST);
  // MEMBER(DATA8 info[13000] NO_INDEX_LIST);
  // MEMBER(DATA16 adc[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_low[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_med[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_high[13000] NO_INDEX_LIST);
  // UINT32 wordA NOENCODE
  // {
    //  0_15: adc_value;
    // 16_21: channel_id = RANGE(0,63);
    // 22_27: module_id = MATCH(module_id);
    //    28: adc_range;
    //    29: 0;
    // 30_31: 3;
  // }
  // UINT32 wordB NOENCODE
  // {
    //  0_27: ts;
    // 28_31: 0;
  // }
  // ENCODE(module APPEND_LIST,(value=static_cast<uint8_t>(module_id)));

  // ENCODE(adc APPEND_LIST,(value=wordA.adc_value));

  // ENCODE(channel APPEND_LIST,(value=wordA.channel_id));

  // ENCODE(ts_low APPEND_LIST,(value=wordB.ts));

  // ENCODE(ts_med APPEND_LIST,(value=0));

  // ENCODE(ts_high APPEND_LIST,(value=0));

  // ENCODE(info APPEND_LIST,(value=255));

}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,AIDA_ADC::__packer,uint32 module_id);

/** END_PACKER ********************************************************/


/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for AIDA_MODULE.
 *
 * Do not edit - automatically generated.
 */

// AIDA_MODULE(module_id,module,channel,info,adc,ts_low,ts_med,ts_high)
#if !PACKER_CODE
# define DECLARED_UNPACK_AIDA_MODULE
class AIDA_MODULE
#else//PACKER_CODE
# define DECLARED_PACKER_AIDA_MODULE
class PACKER_AIDA_MODULE
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA8 module[13000] NO_INDEX_LIST);
  // MEMBER(DATA8 channel[13000] NO_INDEX_LIST);
  // MEMBER(DATA8 info[13000] NO_INDEX_LIST);
  // MEMBER(DATA16 adc[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_low[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_med[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_high[13000] NO_INDEX_LIST);
  // select several

    // i = AIDA_INFO(module_id=module_id,module=module,channel=channel,info=info,
                  // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // d = AIDA_ADC(module_id=module_id,module=module,channel=channel,info=info,
                 // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
  SINGLE(AIDA_INFO,i);
  SINGLE(AIDA_ADC,d);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 module_id,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &module
                                      ,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &channel
                                      ,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &info
                                      ,raw_list_ii_zero_suppress<DATA16,DATA16,13000> &adc
                                      ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_low
                                      ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_med
                                      ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_high);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 module_id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 module_id,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &module
                                       ,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &channel
                                       ,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &info
                                       ,raw_list_ii_zero_suppress<DATA16,DATA16,13000> &adc
                                       ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_low
                                       ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_med
                                       ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_high);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(AIDA_MODULE);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for AIDA_MODULE.
 *
 * Do not edit - automatically generated.
 */

// AIDA_MODULE(module_id,module,channel,info,adc,ts_low,ts_med,ts_high)
template<typename __data_src_t>
void AIDA_MODULE::__unpack(__data_src_t &__buffer,uint32 module_id,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &module
                                                 ,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &channel
                                                 ,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &info
                                                 ,raw_list_ii_zero_suppress<DATA16,DATA16,13000> &adc
                                                 ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_low
                                                 ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_med
                                                 ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_high)
{
  // MEMBER(DATA8 module[13000] NO_INDEX_LIST);
  // MEMBER(DATA8 channel[13000] NO_INDEX_LIST);
  // MEMBER(DATA8 info[13000] NO_INDEX_LIST);
  // MEMBER(DATA16 adc[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_low[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_med[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_high[13000] NO_INDEX_LIST);
  // select several

    // i = AIDA_INFO(module_id=module_id,module=module,channel=channel,info=info,
                  // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // d = AIDA_ADC(module_id=module_id,module=module,channel=channel,info=info,
                 // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: AIDA_INFO i: (s32) => (0xc0000000,0x80000000)
    // optimized match 2: AIDA_ADC d: (s32) => (0xe0000000,0xc0000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(41,uint32,__match_peek);
    // differ = 40000000 : 30
    uint32 __match_index = 0 | /* 30,30 */ ((__match_peek >> 30) & 0x00000001);
    static const sint8 __match_index_array[2] = { 1, 2, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(39,spurious_match_abort_loop_0,AIDA_INFO,/*module_id*/module_id/*,module:member*//*,channel:member*//*,info:member*//*,adc:member*//*,ts_low:member*//*,ts_med:member*//*,ts_high:member*/);
        UNPACK_DECL(39,AIDA_INFO,i,/*module_id*/module_id,/*module*/module,/*channel*/channel,/*info*/info,/*adc*/adc,/*ts_low*/ts_low,/*ts_med*/ts_med,/*ts_high*/ts_high);
        break;
      case 2:
        CHECK_SPURIOUS_MATCH_DECL(40,spurious_match_abort_loop_0,AIDA_ADC,/*module_id*/module_id/*,module:member*//*,channel:member*//*,info:member*//*,adc:member*//*,ts_low:member*//*,ts_med:member*//*,ts_high:member*/);
        UNPACK_DECL(40,AIDA_ADC,d,/*module_id*/module_id,/*module*/module,/*channel*/channel,/*info*/info,/*adc*/adc,/*ts_low*/ts_low,/*ts_med*/ts_med,/*ts_high*/ts_high);
        break;
    }
  }
  spurious_match_abort_loop_0:;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,AIDA_MODULE::__unpack,uint32 module_id,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &module
                                                      ,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &channel
                                                      ,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &info
                                                      ,raw_list_ii_zero_suppress<DATA16,DATA16,13000> &adc
                                                      ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_low
                                                      ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_med
                                                      ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_high);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for AIDA_MODULE.
 *
 * Do not edit - automatically generated.
 */

// AIDA_MODULE(module_id,module,channel,info,adc,ts_low,ts_med,ts_high)
template<typename __data_src_t>
bool AIDA_MODULE::__match(__data_src_t &__buffer,uint32 module_id)
{
  // MEMBER(DATA8 module[13000] NO_INDEX_LIST);
  // MEMBER(DATA8 channel[13000] NO_INDEX_LIST);
  // MEMBER(DATA8 info[13000] NO_INDEX_LIST);
  // MEMBER(DATA16 adc[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_low[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_med[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_high[13000] NO_INDEX_LIST);
  // select several

    // i = AIDA_INFO(module_id=module_id,module=module,channel=channel,info=info,
                  // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // d = AIDA_ADC(module_id=module_id,module=module,channel=channel,info=info,
                 // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    MATCH_DECL(39,__match_no,1,AIDA_INFO,i,/*module_id*/module_id/*,module:member*//*,channel:member*//*,info:member*//*,adc:member*//*,ts_low:member*//*,ts_med:member*//*,ts_high:member*/);
    MATCH_DECL(40,__match_no,2,AIDA_ADC,d,/*module_id*/module_id/*,module:member*//*,channel:member*//*,info:member*//*,adc:member*//*,ts_low:member*//*,ts_med:member*//*,ts_high:member*/);
    if (!__match_no) break;
    return true;
  }
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,AIDA_MODULE::__match,uint32 module_id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for AIDA_MODULE.
 *
 * Do not edit - automatically generated.
 */

// AIDA_MODULE(module_id,module,channel,info,adc,ts_low,ts_med,ts_high)
template<typename __data_dest_t>
void PACKER_AIDA_MODULE::__packer(__data_dest_t &__buffer,uint32 module_id
                                                         ,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &module
                                                         ,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &channel
                                                         ,raw_list_ii_zero_suppress<DATA8,DATA8,13000> &info
                                                         ,raw_list_ii_zero_suppress<DATA16,DATA16,13000> &adc
                                                         ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_low
                                                         ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_med
                                                         ,raw_list_ii_zero_suppress<DATA32,DATA32,13000> &ts_high)
{
  // MEMBER(DATA8 module[13000] NO_INDEX_LIST);
  // MEMBER(DATA8 channel[13000] NO_INDEX_LIST);
  // MEMBER(DATA8 info[13000] NO_INDEX_LIST);
  // MEMBER(DATA16 adc[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_low[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_med[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_high[13000] NO_INDEX_LIST);
  // select several

    // i = AIDA_INFO(module_id=module_id,module=module,channel=channel,info=info,
                  // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // d = AIDA_ADC(module_id=module_id,module=module,channel=channel,info=info,
                 // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
  {
    PACK_DECL(39,AIDA_INFO,i,/*module_id*/module_id,/*module*/module,/*channel*/channel,/*info*/info,/*adc*/adc,/*ts_low*/ts_low,/*ts_med*/ts_med,/*ts_high*/ts_high);
    PACK_DECL(40,AIDA_ADC,d,/*module_id*/module_id,/*module*/module,/*channel*/channel,/*info*/info,/*adc*/adc,/*ts_low*/ts_low,/*ts_med*/ts_med,/*ts_high*/ts_high);
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,AIDA_MODULE::__packer,uint32 module_id);

/** END_PACKER ********************************************************/


/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for AIDA.
 *
 * Do not edit - automatically generated.
 */

// AIDA()
#if !PACKER_CODE
# define DECLARED_UNPACK_AIDA
class AIDA
#else//PACKER_CODE
# define DECLARED_PACKER_AIDA
class PACKER_AIDA
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA8 module[13000] NO_INDEX_LIST);
  raw_list_ii_zero_suppress<DATA8,DATA8,13000> module;
  // MEMBER(DATA8 channel[13000] NO_INDEX_LIST);
  raw_list_ii_zero_suppress<DATA8,DATA8,13000> channel;
  // MEMBER(DATA8 info[13000] NO_INDEX_LIST);
  raw_list_ii_zero_suppress<DATA8,DATA8,13000> info;
  // MEMBER(DATA16 adc[13000] NO_INDEX_LIST);
  raw_list_ii_zero_suppress<DATA16,DATA16,13000> adc;
  // MEMBER(DATA32 ts_low[13000] NO_INDEX_LIST);
  raw_list_ii_zero_suppress<DATA32,DATA32,13000> ts_low;
  // MEMBER(DATA32 ts_med[13000] NO_INDEX_LIST);
  raw_list_ii_zero_suppress<DATA32,DATA32,13000> ts_med;
  // MEMBER(DATA32 ts_high[13000] NO_INDEX_LIST);
  raw_list_ii_zero_suppress<DATA32,DATA32,13000> ts_high;
  // select several

    // mod[0] = AIDA_MODULE(module_id=0,module=module,channel=channel,info=info,
                         // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // mod[1] = AIDA_MODULE(module_id=1,module=module,channel=channel,info=info,
                         // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // mod[2] = AIDA_MODULE(module_id=2,module=module,channel=channel,info=info,
                         // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // mod[3] = AIDA_MODULE(module_id=3,module=module,channel=channel,info=info,
                         // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // mod[4] = AIDA_MODULE(module_id=4,module=module,channel=channel,info=info,
                         // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // mod[5] = AIDA_MODULE(module_id=5,module=module,channel=channel,info=info,
                         // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // mod[6] = AIDA_MODULE(module_id=6,module=module,channel=channel,info=info,
                         // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // mod[7] = AIDA_MODULE(module_id=7,module=module,channel=channel,info=info,
                         // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // mod[8] = AIDA_MODULE(module_id=8,module=module,channel=channel,info=info,
                         // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // mod[9] = AIDA_MODULE(module_id=9,module=module,channel=channel,info=info,
                         // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // mod[10] = AIDA_MODULE(module_id=10,module=module,channel=channel,
                          // info=info,adc=adc,ts_low=ts_low,ts_med=ts_med,
                          // ts_high=ts_high);
    // mod[11] = AIDA_MODULE(module_id=11,module=module,channel=channel,
                          // info=info,adc=adc,ts_low=ts_low,ts_med=ts_med,
                          // ts_high=ts_high);
  SINGLE(AIDA_MODULE,mod[12]);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(AIDA);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for AIDA.
 *
 * Do not edit - automatically generated.
 */

// AIDA()
template<typename __data_src_t>
void AIDA::__unpack(__data_src_t &__buffer)
{
  // MEMBER(DATA8 module[13000] NO_INDEX_LIST);
  // MEMBER(DATA8 channel[13000] NO_INDEX_LIST);
  // MEMBER(DATA8 info[13000] NO_INDEX_LIST);
  // MEMBER(DATA16 adc[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_low[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_med[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_high[13000] NO_INDEX_LIST);
  // select several

    // mod[0] = AIDA_MODULE(module_id=0,module=module,channel=channel,info=info,
                         // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // mod[1] = AIDA_MODULE(module_id=1,module=module,channel=channel,info=info,
                         // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // mod[2] = AIDA_MODULE(module_id=2,module=module,channel=channel,info=info,
                         // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // mod[3] = AIDA_MODULE(module_id=3,module=module,channel=channel,info=info,
                         // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // mod[4] = AIDA_MODULE(module_id=4,module=module,channel=channel,info=info,
                         // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // mod[5] = AIDA_MODULE(module_id=5,module=module,channel=channel,info=info,
                         // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // mod[6] = AIDA_MODULE(module_id=6,module=module,channel=channel,info=info,
                         // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // mod[7] = AIDA_MODULE(module_id=7,module=module,channel=channel,info=info,
                         // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // mod[8] = AIDA_MODULE(module_id=8,module=module,channel=channel,info=info,
                         // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // mod[9] = AIDA_MODULE(module_id=9,module=module,channel=channel,info=info,
                         // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // mod[10] = AIDA_MODULE(module_id=10,module=module,channel=channel,
                          // info=info,adc=adc,ts_low=ts_low,ts_med=ts_med,
                          // ts_high=ts_high);
    // mod[11] = AIDA_MODULE(module_id=11,module=module,channel=channel,
                          // info=info,adc=adc,ts_low=ts_low,ts_med=ts_med,
                          // ts_high=ts_high);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: AIDA_MODULE mod[0]: could not get bits
    __buffer.peeking();
    MATCH_DECL(17,__match_no,1,AIDA_MODULE,mod[0],/*module_id*/0/*,module:member*//*,channel:member*//*,info:member*//*,adc:member*//*,ts_low:member*//*,ts_med:member*//*,ts_high:member*/);
    MATCH_DECL(18,__match_no,2,AIDA_MODULE,mod[1],/*module_id*/1/*,module:member*//*,channel:member*//*,info:member*//*,adc:member*//*,ts_low:member*//*,ts_med:member*//*,ts_high:member*/);
    MATCH_DECL(19,__match_no,3,AIDA_MODULE,mod[2],/*module_id*/2/*,module:member*//*,channel:member*//*,info:member*//*,adc:member*//*,ts_low:member*//*,ts_med:member*//*,ts_high:member*/);
    MATCH_DECL(20,__match_no,4,AIDA_MODULE,mod[3],/*module_id*/3/*,module:member*//*,channel:member*//*,info:member*//*,adc:member*//*,ts_low:member*//*,ts_med:member*//*,ts_high:member*/);
    MATCH_DECL(21,__match_no,5,AIDA_MODULE,mod[4],/*module_id*/4/*,module:member*//*,channel:member*//*,info:member*//*,adc:member*//*,ts_low:member*//*,ts_med:member*//*,ts_high:member*/);
    MATCH_DECL(22,__match_no,6,AIDA_MODULE,mod[5],/*module_id*/5/*,module:member*//*,channel:member*//*,info:member*//*,adc:member*//*,ts_low:member*//*,ts_med:member*//*,ts_high:member*/);
    MATCH_DECL(23,__match_no,7,AIDA_MODULE,mod[6],/*module_id*/6/*,module:member*//*,channel:member*//*,info:member*//*,adc:member*//*,ts_low:member*//*,ts_med:member*//*,ts_high:member*/);
    MATCH_DECL(24,__match_no,8,AIDA_MODULE,mod[7],/*module_id*/7/*,module:member*//*,channel:member*//*,info:member*//*,adc:member*//*,ts_low:member*//*,ts_med:member*//*,ts_high:member*/);
    MATCH_DECL(25,__match_no,9,AIDA_MODULE,mod[8],/*module_id*/8/*,module:member*//*,channel:member*//*,info:member*//*,adc:member*//*,ts_low:member*//*,ts_med:member*//*,ts_high:member*/);
    MATCH_DECL(26,__match_no,10,AIDA_MODULE,mod[9],/*module_id*/9/*,module:member*//*,channel:member*//*,info:member*//*,adc:member*//*,ts_low:member*//*,ts_med:member*//*,ts_high:member*/);
    MATCH_DECL(27,__match_no,11,AIDA_MODULE,mod[10],/*module_id*/10/*,module:member*//*,channel:member*//*,info:member*//*,adc:member*//*,ts_low:member*//*,ts_med:member*//*,ts_high:member*/);
    MATCH_DECL(28,__match_no,12,AIDA_MODULE,mod[11],/*module_id*/11/*,module:member*//*,channel:member*//*,info:member*//*,adc:member*//*,ts_low:member*//*,ts_med:member*//*,ts_high:member*/);
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(17,AIDA_MODULE,mod[0],/*module_id*/0,/*module*/module,/*channel*/channel,/*info*/info,/*adc*/adc,/*ts_low*/ts_low,/*ts_med*/ts_med,/*ts_high*/ts_high);
        break;
      case 2:
        UNPACK_DECL(18,AIDA_MODULE,mod[1],/*module_id*/1,/*module*/module,/*channel*/channel,/*info*/info,/*adc*/adc,/*ts_low*/ts_low,/*ts_med*/ts_med,/*ts_high*/ts_high);
        break;
      case 3:
        UNPACK_DECL(19,AIDA_MODULE,mod[2],/*module_id*/2,/*module*/module,/*channel*/channel,/*info*/info,/*adc*/adc,/*ts_low*/ts_low,/*ts_med*/ts_med,/*ts_high*/ts_high);
        break;
      case 4:
        UNPACK_DECL(20,AIDA_MODULE,mod[3],/*module_id*/3,/*module*/module,/*channel*/channel,/*info*/info,/*adc*/adc,/*ts_low*/ts_low,/*ts_med*/ts_med,/*ts_high*/ts_high);
        break;
      case 5:
        UNPACK_DECL(21,AIDA_MODULE,mod[4],/*module_id*/4,/*module*/module,/*channel*/channel,/*info*/info,/*adc*/adc,/*ts_low*/ts_low,/*ts_med*/ts_med,/*ts_high*/ts_high);
        break;
      case 6:
        UNPACK_DECL(22,AIDA_MODULE,mod[5],/*module_id*/5,/*module*/module,/*channel*/channel,/*info*/info,/*adc*/adc,/*ts_low*/ts_low,/*ts_med*/ts_med,/*ts_high*/ts_high);
        break;
      case 7:
        UNPACK_DECL(23,AIDA_MODULE,mod[6],/*module_id*/6,/*module*/module,/*channel*/channel,/*info*/info,/*adc*/adc,/*ts_low*/ts_low,/*ts_med*/ts_med,/*ts_high*/ts_high);
        break;
      case 8:
        UNPACK_DECL(24,AIDA_MODULE,mod[7],/*module_id*/7,/*module*/module,/*channel*/channel,/*info*/info,/*adc*/adc,/*ts_low*/ts_low,/*ts_med*/ts_med,/*ts_high*/ts_high);
        break;
      case 9:
        UNPACK_DECL(25,AIDA_MODULE,mod[8],/*module_id*/8,/*module*/module,/*channel*/channel,/*info*/info,/*adc*/adc,/*ts_low*/ts_low,/*ts_med*/ts_med,/*ts_high*/ts_high);
        break;
      case 10:
        UNPACK_DECL(26,AIDA_MODULE,mod[9],/*module_id*/9,/*module*/module,/*channel*/channel,/*info*/info,/*adc*/adc,/*ts_low*/ts_low,/*ts_med*/ts_med,/*ts_high*/ts_high);
        break;
      case 11:
        UNPACK_DECL(27,AIDA_MODULE,mod[10],/*module_id*/10,/*module*/module,/*channel*/channel,/*info*/info,/*adc*/adc,/*ts_low*/ts_low,/*ts_med*/ts_med,/*ts_high*/ts_high);
        break;
      case 12:
        UNPACK_DECL(28,AIDA_MODULE,mod[11],/*module_id*/11,/*module*/module,/*channel*/channel,/*info*/info,/*adc*/adc,/*ts_low*/ts_low,/*ts_med*/ts_med,/*ts_high*/ts_high);
        break;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,AIDA::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for AIDA.
 *
 * Do not edit - automatically generated.
 */

// AIDA()
template<typename __data_src_t>
bool AIDA::__match(__data_src_t &__buffer)
{
  // MEMBER(DATA8 module[13000] NO_INDEX_LIST);
  // MEMBER(DATA8 channel[13000] NO_INDEX_LIST);
  // MEMBER(DATA8 info[13000] NO_INDEX_LIST);
  // MEMBER(DATA16 adc[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_low[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_med[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_high[13000] NO_INDEX_LIST);
  // select several

    // mod[0] = AIDA_MODULE(module_id=0,module=module,channel=channel,info=info,
                         // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // mod[1] = AIDA_MODULE(module_id=1,module=module,channel=channel,info=info,
                         // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // mod[2] = AIDA_MODULE(module_id=2,module=module,channel=channel,info=info,
                         // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // mod[3] = AIDA_MODULE(module_id=3,module=module,channel=channel,info=info,
                         // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // mod[4] = AIDA_MODULE(module_id=4,module=module,channel=channel,info=info,
                         // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // mod[5] = AIDA_MODULE(module_id=5,module=module,channel=channel,info=info,
                         // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // mod[6] = AIDA_MODULE(module_id=6,module=module,channel=channel,info=info,
                         // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // mod[7] = AIDA_MODULE(module_id=7,module=module,channel=channel,info=info,
                         // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // mod[8] = AIDA_MODULE(module_id=8,module=module,channel=channel,info=info,
                         // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // mod[9] = AIDA_MODULE(module_id=9,module=module,channel=channel,info=info,
                         // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // mod[10] = AIDA_MODULE(module_id=10,module=module,channel=channel,
                          // info=info,adc=adc,ts_low=ts_low,ts_med=ts_med,
                          // ts_high=ts_high);
    // mod[11] = AIDA_MODULE(module_id=11,module=module,channel=channel,
                          // info=info,adc=adc,ts_low=ts_low,ts_med=ts_med,
                          // ts_high=ts_high);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    MATCH_DECL(17,__match_no,1,AIDA_MODULE,mod[0],/*module_id*/0/*,module:member*//*,channel:member*//*,info:member*//*,adc:member*//*,ts_low:member*//*,ts_med:member*//*,ts_high:member*/);
    MATCH_DECL(18,__match_no,2,AIDA_MODULE,mod[1],/*module_id*/1/*,module:member*//*,channel:member*//*,info:member*//*,adc:member*//*,ts_low:member*//*,ts_med:member*//*,ts_high:member*/);
    MATCH_DECL(19,__match_no,3,AIDA_MODULE,mod[2],/*module_id*/2/*,module:member*//*,channel:member*//*,info:member*//*,adc:member*//*,ts_low:member*//*,ts_med:member*//*,ts_high:member*/);
    MATCH_DECL(20,__match_no,4,AIDA_MODULE,mod[3],/*module_id*/3/*,module:member*//*,channel:member*//*,info:member*//*,adc:member*//*,ts_low:member*//*,ts_med:member*//*,ts_high:member*/);
    MATCH_DECL(21,__match_no,5,AIDA_MODULE,mod[4],/*module_id*/4/*,module:member*//*,channel:member*//*,info:member*//*,adc:member*//*,ts_low:member*//*,ts_med:member*//*,ts_high:member*/);
    MATCH_DECL(22,__match_no,6,AIDA_MODULE,mod[5],/*module_id*/5/*,module:member*//*,channel:member*//*,info:member*//*,adc:member*//*,ts_low:member*//*,ts_med:member*//*,ts_high:member*/);
    MATCH_DECL(23,__match_no,7,AIDA_MODULE,mod[6],/*module_id*/6/*,module:member*//*,channel:member*//*,info:member*//*,adc:member*//*,ts_low:member*//*,ts_med:member*//*,ts_high:member*/);
    MATCH_DECL(24,__match_no,8,AIDA_MODULE,mod[7],/*module_id*/7/*,module:member*//*,channel:member*//*,info:member*//*,adc:member*//*,ts_low:member*//*,ts_med:member*//*,ts_high:member*/);
    MATCH_DECL(25,__match_no,9,AIDA_MODULE,mod[8],/*module_id*/8/*,module:member*//*,channel:member*//*,info:member*//*,adc:member*//*,ts_low:member*//*,ts_med:member*//*,ts_high:member*/);
    MATCH_DECL(26,__match_no,10,AIDA_MODULE,mod[9],/*module_id*/9/*,module:member*//*,channel:member*//*,info:member*//*,adc:member*//*,ts_low:member*//*,ts_med:member*//*,ts_high:member*/);
    MATCH_DECL(27,__match_no,11,AIDA_MODULE,mod[10],/*module_id*/10/*,module:member*//*,channel:member*//*,info:member*//*,adc:member*//*,ts_low:member*//*,ts_med:member*//*,ts_high:member*/);
    MATCH_DECL(28,__match_no,12,AIDA_MODULE,mod[11],/*module_id*/11/*,module:member*//*,channel:member*//*,info:member*//*,adc:member*//*,ts_low:member*//*,ts_med:member*//*,ts_high:member*/);
    if (!__match_no) break;
    return true;
  }
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,AIDA::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for AIDA.
 *
 * Do not edit - automatically generated.
 */

// AIDA()
template<typename __data_dest_t>
void PACKER_AIDA::__packer(__data_dest_t &__buffer)
{
  // MEMBER(DATA8 module[13000] NO_INDEX_LIST);
  // MEMBER(DATA8 channel[13000] NO_INDEX_LIST);
  // MEMBER(DATA8 info[13000] NO_INDEX_LIST);
  // MEMBER(DATA16 adc[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_low[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_med[13000] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_high[13000] NO_INDEX_LIST);
  // select several

    // mod[0] = AIDA_MODULE(module_id=0,module=module,channel=channel,info=info,
                         // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // mod[1] = AIDA_MODULE(module_id=1,module=module,channel=channel,info=info,
                         // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // mod[2] = AIDA_MODULE(module_id=2,module=module,channel=channel,info=info,
                         // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // mod[3] = AIDA_MODULE(module_id=3,module=module,channel=channel,info=info,
                         // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // mod[4] = AIDA_MODULE(module_id=4,module=module,channel=channel,info=info,
                         // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // mod[5] = AIDA_MODULE(module_id=5,module=module,channel=channel,info=info,
                         // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // mod[6] = AIDA_MODULE(module_id=6,module=module,channel=channel,info=info,
                         // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // mod[7] = AIDA_MODULE(module_id=7,module=module,channel=channel,info=info,
                         // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // mod[8] = AIDA_MODULE(module_id=8,module=module,channel=channel,info=info,
                         // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // mod[9] = AIDA_MODULE(module_id=9,module=module,channel=channel,info=info,
                         // adc=adc,ts_low=ts_low,ts_med=ts_med,ts_high=ts_high);
    // mod[10] = AIDA_MODULE(module_id=10,module=module,channel=channel,
                          // info=info,adc=adc,ts_low=ts_low,ts_med=ts_med,
                          // ts_high=ts_high);
    // mod[11] = AIDA_MODULE(module_id=11,module=module,channel=channel,
                          // info=info,adc=adc,ts_low=ts_low,ts_med=ts_med,
                          // ts_high=ts_high);
  {
    PACK_DECL(17,AIDA_MODULE,mod[0],/*module_id*/0,/*module*/module,/*channel*/channel,/*info*/info,/*adc*/adc,/*ts_low*/ts_low,/*ts_med*/ts_med,/*ts_high*/ts_high);
    PACK_DECL(18,AIDA_MODULE,mod[1],/*module_id*/1,/*module*/module,/*channel*/channel,/*info*/info,/*adc*/adc,/*ts_low*/ts_low,/*ts_med*/ts_med,/*ts_high*/ts_high);
    PACK_DECL(19,AIDA_MODULE,mod[2],/*module_id*/2,/*module*/module,/*channel*/channel,/*info*/info,/*adc*/adc,/*ts_low*/ts_low,/*ts_med*/ts_med,/*ts_high*/ts_high);
    PACK_DECL(20,AIDA_MODULE,mod[3],/*module_id*/3,/*module*/module,/*channel*/channel,/*info*/info,/*adc*/adc,/*ts_low*/ts_low,/*ts_med*/ts_med,/*ts_high*/ts_high);
    PACK_DECL(21,AIDA_MODULE,mod[4],/*module_id*/4,/*module*/module,/*channel*/channel,/*info*/info,/*adc*/adc,/*ts_low*/ts_low,/*ts_med*/ts_med,/*ts_high*/ts_high);
    PACK_DECL(22,AIDA_MODULE,mod[5],/*module_id*/5,/*module*/module,/*channel*/channel,/*info*/info,/*adc*/adc,/*ts_low*/ts_low,/*ts_med*/ts_med,/*ts_high*/ts_high);
    PACK_DECL(23,AIDA_MODULE,mod[6],/*module_id*/6,/*module*/module,/*channel*/channel,/*info*/info,/*adc*/adc,/*ts_low*/ts_low,/*ts_med*/ts_med,/*ts_high*/ts_high);
    PACK_DECL(24,AIDA_MODULE,mod[7],/*module_id*/7,/*module*/module,/*channel*/channel,/*info*/info,/*adc*/adc,/*ts_low*/ts_low,/*ts_med*/ts_med,/*ts_high*/ts_high);
    PACK_DECL(25,AIDA_MODULE,mod[8],/*module_id*/8,/*module*/module,/*channel*/channel,/*info*/info,/*adc*/adc,/*ts_low*/ts_low,/*ts_med*/ts_med,/*ts_high*/ts_high);
    PACK_DECL(26,AIDA_MODULE,mod[9],/*module_id*/9,/*module*/module,/*channel*/channel,/*info*/info,/*adc*/adc,/*ts_low*/ts_low,/*ts_med*/ts_med,/*ts_high*/ts_high);
    PACK_DECL(27,AIDA_MODULE,mod[10],/*module_id*/10,/*module*/module,/*channel*/channel,/*info*/info,/*adc*/adc,/*ts_low*/ts_low,/*ts_med*/ts_med,/*ts_high*/ts_high);
    PACK_DECL(28,AIDA_MODULE,mod[11],/*module_id*/11,/*module*/module,/*channel*/channel,/*info*/info,/*adc*/adc,/*ts_low*/ts_low,/*ts_med*/ts_med,/*ts_high*/ts_high);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,AIDA::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: DUMMY
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for DUMMY.
 *
 * Do not edit - automatically generated.
 */

// DUMMY()
#if !PACKER_CODE
# define DECLARED_UNPACK_DUMMY
class DUMMY
#else//PACKER_CODE
# define DECLARED_PACKER_DUMMY
class PACKER_DUMMY
#endif//PACKER_CODE

{
public:
  // UINT32 no NOENCODE;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(DUMMY);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for DUMMY.
 *
 * Do not edit - automatically generated.
 */

// DUMMY()
template<typename __data_src_t>
void DUMMY::__unpack(__data_src_t &__buffer)
{
  // UINT32 no NOENCODE;
  uint32  no;READ_FROM_BUFFER(360,uint32 ,no,6);
}
FORCE_IMPL_DATA_SRC_FCN(void,DUMMY::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for DUMMY.
 *
 * Do not edit - automatically generated.
 */

// DUMMY()
template<typename __data_src_t>
bool DUMMY::__match(__data_src_t &__buffer)
{
  // UINT32 no NOENCODE;
  uint32  no;
  MATCH_READ_FROM_BUFFER(360,uint32 ,no,7);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,DUMMY::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for DUMMY.
 *
 * Do not edit - automatically generated.
 */

// DUMMY()
template<typename __data_dest_t>
void PACKER_DUMMY::__packer(__data_dest_t &__buffer)
{
  // UINT32 no NOENCODE;
}
FORCE_IMPL_DATA_SRC_FCN(void,DUMMY::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: EXT_AIDA
//

// Structure is external.  Must be provided by the user


/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for EXT_AIDA.
 *
 * Do not edit - automatically generated.
 */


/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for EXT_AIDA.
 *
 * Do not edit - automatically generated.
 */


/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for EXT_AIDA.
 *
 * Do not edit - automatically generated.
 */


/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for EXT_AIDA.
 *
 * Do not edit - automatically generated.
 */


/** END_PACKER ********************************************************/

//
// Generating code for: EXT_FATIMA_TAMEX
//

// Structure is external.  Must be provided by the user


/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for EXT_FATIMA_TAMEX.
 *
 * Do not edit - automatically generated.
 */


/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for EXT_FATIMA_TAMEX.
 *
 * Do not edit - automatically generated.
 */


/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for EXT_FATIMA_TAMEX.
 *
 * Do not edit - automatically generated.
 */


/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for EXT_FATIMA_TAMEX.
 *
 * Do not edit - automatically generated.
 */


/** END_PACKER ********************************************************/

//
// Generating code for: EXT_FATIMA_VME
//

// Structure is external.  Must be provided by the user


/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for EXT_FATIMA_VME.
 *
 * Do not edit - automatically generated.
 */


/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for EXT_FATIMA_VME.
 *
 * Do not edit - automatically generated.
 */


/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for EXT_FATIMA_VME.
 *
 * Do not edit - automatically generated.
 */


/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for EXT_FATIMA_VME.
 *
 * Do not edit - automatically generated.
 */


/** END_PACKER ********************************************************/

//
// Generating code for: EXT_GERMANIUM
//

// Structure is external.  Must be provided by the user


/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for EXT_GERMANIUM.
 *
 * Do not edit - automatically generated.
 */


/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for EXT_GERMANIUM.
 *
 * Do not edit - automatically generated.
 */


/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for EXT_GERMANIUM.
 *
 * Do not edit - automatically generated.
 */


/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for EXT_GERMANIUM.
 *
 * Do not edit - automatically generated.
 */


/** END_PACKER ********************************************************/

//
// Generating code for: FATIMA_QDC
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for FATIMA_QDC.
 *
 * Do not edit - automatically generated.
 */

// FATIMA_QDC()
#if !PACKER_CODE
# define DECLARED_UNPACK_FATIMA_QDC
class FATIMA_QDC
#else//PACKER_CODE
# define DECLARED_PACKER_FATIMA_QDC
class PACKER_FATIMA_QDC
#endif//PACKER_CODE

{
public:

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(FATIMA_QDC);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for FATIMA_QDC.
 *
 * Do not edit - automatically generated.
 */

// FATIMA_QDC()
template<typename __data_src_t>
void FATIMA_QDC::__unpack(__data_src_t &__buffer)
{
}
FORCE_IMPL_DATA_SRC_FCN(void,FATIMA_QDC::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for FATIMA_QDC.
 *
 * Do not edit - automatically generated.
 */

// FATIMA_QDC()
template<typename __data_src_t>
bool FATIMA_QDC::__match(__data_src_t &__buffer)
{
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,FATIMA_QDC::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for FATIMA_QDC.
 *
 * Do not edit - automatically generated.
 */

// FATIMA_QDC()
template<typename __data_dest_t>
void PACKER_FATIMA_QDC::__packer(__data_dest_t &__buffer)
{
}
FORCE_IMPL_DATA_SRC_FCN(void,FATIMA_QDC::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: FATIMA_SCALER
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for FATIMA_SCALER.
 *
 * Do not edit - automatically generated.
 */

// FATIMA_SCALER()
#if !PACKER_CODE
# define DECLARED_UNPACK_FATIMA_SCALER
class FATIMA_SCALER
#else//PACKER_CODE
# define DECLARED_PACKER_FATIMA_SCALER
class PACKER_FATIMA_SCALER
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA32 scalers[16] ZERO_SUPPRESS_LIST);
  raw_list_zero_suppress<DATA32,DATA32,16> scalers;
  // UINT32 header NOENCODE
  // {
    //  0_31: h = CHECK(0x7a001000);
  // }
  // list(0<=index<16)

    // UINT32 ch_data NOENCODE;
    // ENCODE(scalers[index],(value=ch_data));

  // UINT32 trailer NOENCODE
  // {
    //  0_31: t = CHECK(0x7c000000);
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(FATIMA_SCALER);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for FATIMA_SCALER.
 *
 * Do not edit - automatically generated.
 */

// FATIMA_SCALER()
template<typename __data_src_t>
void FATIMA_SCALER::__unpack(__data_src_t &__buffer)
{
  // MEMBER(DATA32 scalers[16] ZERO_SUPPRESS_LIST);
  // UINT32 header NOENCODE
  // {
    //  0_31: h = CHECK(0x7a001000);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 h : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 h : 32; // 0..31
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(159,uint32 ,header,header.u32,8);
  CHECK_BITS_EQUAL(157,header.h,0x7a001000);
  // list(0<=index<16)

  for (uint32 index = 0; index < (uint32) (16); ++index)
  {
    // UINT32 ch_data NOENCODE;
    uint32  ch_data;READ_FROM_BUFFER(163,uint32 ,ch_data,9);
    // ENCODE(scalers[index],(value=ch_data));

    {
      typedef __typeof__(*(&(scalers))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = scalers.insert_index(164,index);
      __item.value = ch_data;
    }
  }
  // UINT32 trailer NOENCODE
  // {
    //  0_31: t = CHECK(0x7c000000);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 t : 32; // 0..31
#endif
    };
    uint32  u32;
  } trailer;
  READ_FROM_BUFFER_FULL(170,uint32 ,trailer,trailer.u32,10);
  CHECK_BITS_EQUAL(169,trailer.t,0x7c000000);
}
FORCE_IMPL_DATA_SRC_FCN(void,FATIMA_SCALER::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for FATIMA_SCALER.
 *
 * Do not edit - automatically generated.
 */

// FATIMA_SCALER()
template<typename __data_src_t>
bool FATIMA_SCALER::__match(__data_src_t &__buffer)
{
  // MEMBER(DATA32 scalers[16] ZERO_SUPPRESS_LIST);
  // UINT32 header NOENCODE
  // {
    //  0_31: h = CHECK(0x7a001000);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 h : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 h : 32; // 0..31
#endif
    };
    uint32  u32;
  } header;
  MATCH_READ_FROM_BUFFER_FULL(159,uint32 ,header,header.u32,11);
  MATCH_BITS_EQUAL(157,header.h,0x7a001000);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,FATIMA_SCALER::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for FATIMA_SCALER.
 *
 * Do not edit - automatically generated.
 */

// FATIMA_SCALER()
template<typename __data_dest_t>
void PACKER_FATIMA_SCALER::__packer(__data_dest_t &__buffer)
{
  // MEMBER(DATA32 scalers[16] ZERO_SUPPRESS_LIST);
  // UINT32 header NOENCODE
  // {
    //  0_31: h = CHECK(0x7a001000);
  // }
  // list(0<=index<16)

  {
    // UINT32 ch_data NOENCODE;
    // ENCODE(scalers[index],(value=ch_data));

  }
  // UINT32 trailer NOENCODE
  // {
    //  0_31: t = CHECK(0x7c000000);
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,FATIMA_SCALER::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: FATIMA_TAMEX
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for FATIMA_TAMEX.
 *
 * Do not edit - automatically generated.
 */

// FATIMA_TAMEX()
#if !PACKER_CODE
# define DECLARED_UNPACK_FATIMA_TAMEX
class FATIMA_TAMEX
#else//PACKER_CODE
# define DECLARED_PACKER_FATIMA_TAMEX
class PACKER_FATIMA_TAMEX
#endif//PACKER_CODE

{
public:
  // select several

    // dummy = DUMMY();
  SINGLE(DUMMY,dummy);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(FATIMA_TAMEX);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for FATIMA_TAMEX.
 *
 * Do not edit - automatically generated.
 */

// FATIMA_TAMEX()
template<typename __data_src_t>
void FATIMA_TAMEX::__unpack(__data_src_t &__buffer)
{
  // select several

    // dummy = DUMMY();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: DUMMY dummy: (s32)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(145,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(144,spurious_match_abort_loop_2,DUMMY);
        UNPACK_DECL(144,DUMMY,dummy);
        break;
    }
  }
  spurious_match_abort_loop_2:;
}
FORCE_IMPL_DATA_SRC_FCN(void,FATIMA_TAMEX::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for FATIMA_TAMEX.
 *
 * Do not edit - automatically generated.
 */

// FATIMA_TAMEX()
template<typename __data_src_t>
bool FATIMA_TAMEX::__match(__data_src_t &__buffer)
{
  // select several

    // dummy = DUMMY();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    MATCH_DECL(144,__match_no,1,DUMMY,dummy);
    if (!__match_no) break;
    return true;
  }
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,FATIMA_TAMEX::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for FATIMA_TAMEX.
 *
 * Do not edit - automatically generated.
 */

// FATIMA_TAMEX()
template<typename __data_dest_t>
void PACKER_FATIMA_TAMEX::__packer(__data_dest_t &__buffer)
{
  // select several

    // dummy = DUMMY();
  {
    PACK_DECL(144,DUMMY,dummy);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,FATIMA_TAMEX::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: FATIMA_TDC
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for FATIMA_TDC.
 *
 * Do not edit - automatically generated.
 */

// FATIMA_TDC()
#if !PACKER_CODE
# define DECLARED_UNPACK_FATIMA_TDC
class FATIMA_TDC
#else//PACKER_CODE
# define DECLARED_PACKER_FATIMA_TDC
class PACKER_FATIMA_TDC
#endif//PACKER_CODE

{
public:

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(FATIMA_TDC);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for FATIMA_TDC.
 *
 * Do not edit - automatically generated.
 */

// FATIMA_TDC()
template<typename __data_src_t>
void FATIMA_TDC::__unpack(__data_src_t &__buffer)
{
}
FORCE_IMPL_DATA_SRC_FCN(void,FATIMA_TDC::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for FATIMA_TDC.
 *
 * Do not edit - automatically generated.
 */

// FATIMA_TDC()
template<typename __data_src_t>
bool FATIMA_TDC::__match(__data_src_t &__buffer)
{
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,FATIMA_TDC::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for FATIMA_TDC.
 *
 * Do not edit - automatically generated.
 */

// FATIMA_TDC()
template<typename __data_dest_t>
void PACKER_FATIMA_TDC::__packer(__data_dest_t &__buffer)
{
}
FORCE_IMPL_DATA_SRC_FCN(void,FATIMA_TDC::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: FATIMA_VME
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for FATIMA_VME.
 *
 * Do not edit - automatically generated.
 */

// FATIMA_VME()
#if !PACKER_CODE
# define DECLARED_UNPACK_FATIMA_VME
class FATIMA_VME
#else//PACKER_CODE
# define DECLARED_PACKER_FATIMA_VME
class PACKER_FATIMA_VME
#endif//PACKER_CODE

{
public:
  // select optional

    // scaler = FATIMA_SCALER();
  SINGLE(FATIMA_SCALER,scaler);
  // select several

    // dummy = DUMMY();
  SINGLE(DUMMY,dummy);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(FATIMA_VME);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for FATIMA_VME.
 *
 * Do not edit - automatically generated.
 */

// FATIMA_VME()
template<typename __data_src_t>
void FATIMA_VME::__unpack(__data_src_t &__buffer)
{
  // select optional

    // scaler = FATIMA_SCALER();
  do
  {
    if (__buffer.empty()) goto no_match_1;
    int __match_no = 0;
    // optimized match 1: FATIMA_SCALER scaler: (s32) => (0xffffffff,0x7a001000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(132,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) goto no_match_1;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(131,spurious_match_abort_loop_3,FATIMA_SCALER);
        UNPACK_DECL(131,FATIMA_SCALER,scaler);
        break;
    }
  }
  while (0);
  spurious_match_abort_loop_3:;
    no_match_1:;
  // select several

    // dummy = DUMMY();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: DUMMY dummy: (s32)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(136,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(135,spurious_match_abort_loop_4,DUMMY);
        UNPACK_DECL(135,DUMMY,dummy);
        break;
    }
  }
  spurious_match_abort_loop_4:;
}
FORCE_IMPL_DATA_SRC_FCN(void,FATIMA_VME::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for FATIMA_VME.
 *
 * Do not edit - automatically generated.
 */

// FATIMA_VME()
template<typename __data_src_t>
bool FATIMA_VME::__match(__data_src_t &__buffer)
{
  // select optional

    // scaler = FATIMA_SCALER();
  do
  {
    if (__buffer.empty()) goto no_match_2;
    int __match_no = 0;
    MATCH_DECL(131,__match_no,1,FATIMA_SCALER,scaler);
    if (!__match_no) goto no_match_2;
    return true;
  }
  while (0);
    no_match_2:;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,FATIMA_VME::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for FATIMA_VME.
 *
 * Do not edit - automatically generated.
 */

// FATIMA_VME()
template<typename __data_dest_t>
void PACKER_FATIMA_VME::__packer(__data_dest_t &__buffer)
{
  // select optional

    // scaler = FATIMA_SCALER();
  {
    PACK_DECL(131,FATIMA_SCALER,scaler);
  }
  // select several

    // dummy = DUMMY();
  {
    PACK_DECL(135,DUMMY,dummy);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,FATIMA_VME::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: FRS
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for FRS.
 *
 * Do not edit - automatically generated.
 */

// FRS()
#if !PACKER_CODE
# define DECLARED_UNPACK_FRS
class FRS
#else//PACKER_CODE
# define DECLARED_PACKER_FRS
class PACKER_FRS
#endif//PACKER_CODE

{
public:
  // select several

    // dummy = DUMMY();
  SINGLE(DUMMY,dummy);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(FRS);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for FRS.
 *
 * Do not edit - automatically generated.
 */

// FRS()
template<typename __data_src_t>
void FRS::__unpack(__data_src_t &__buffer)
{
  // select several

    // dummy = DUMMY();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: DUMMY dummy: (s32)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(190,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(189,spurious_match_abort_loop_5,DUMMY);
        UNPACK_DECL(189,DUMMY,dummy);
        break;
    }
  }
  spurious_match_abort_loop_5:;
}
FORCE_IMPL_DATA_SRC_FCN(void,FRS::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for FRS.
 *
 * Do not edit - automatically generated.
 */

// FRS()
template<typename __data_src_t>
bool FRS::__match(__data_src_t &__buffer)
{
  // select several

    // dummy = DUMMY();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    MATCH_DECL(189,__match_no,1,DUMMY,dummy);
    if (!__match_no) break;
    return true;
  }
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,FRS::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for FRS.
 *
 * Do not edit - automatically generated.
 */

// FRS()
template<typename __data_dest_t>
void PACKER_FRS::__packer(__data_dest_t &__buffer)
{
  // select several

    // dummy = DUMMY();
  {
    PACK_DECL(189,DUMMY,dummy);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,FRS::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: FRS_FRS
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for FRS_FRS.
 *
 * Do not edit - automatically generated.
 */

// FRS_FRS()
#if !PACKER_CODE
# define DECLARED_UNPACK_FRS_FRS
class FRS_FRS
#else//PACKER_CODE
# define DECLARED_PACKER_FRS_FRS
class PACKER_FRS_FRS
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA32 scalers[32] ZERO_SUPPRESS_LIST);
  raw_list_zero_suppress<DATA32,DATA32,32> scalers;
  // UINT32 no NOENCODE;
  // if(((no & 0xffff0000) == 0x04400000))

    // list(0<=index<32)

      // UINT32 ch_data NOENCODE;
      // ENCODE(scalers[index],(value=ch_data));


public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(FRS_FRS);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for FRS_FRS.
 *
 * Do not edit - automatically generated.
 */

// FRS_FRS()
template<typename __data_src_t>
void FRS_FRS::__unpack(__data_src_t &__buffer)
{
  // MEMBER(DATA32 scalers[32] ZERO_SUPPRESS_LIST);
  // UINT32 no NOENCODE;
  uint32  no;READ_FROM_BUFFER(215,uint32 ,no,12);
  // if(((no & 0xffff0000) == 0x04400000))

  if (((no & 0xffff0000) == 0x04400000))
  {
    // list(0<=index<32)

    for (uint32 index = 0; index < (uint32) (32); ++index)
    {
      // UINT32 ch_data NOENCODE;
      uint32  ch_data;READ_FROM_BUFFER(221,uint32 ,ch_data,13);
      // ENCODE(scalers[index],(value=ch_data));

      {
        typedef __typeof__(*(&(scalers))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = scalers.insert_index(222,index);
        __item.value = ch_data;
      }
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,FRS_FRS::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for FRS_FRS.
 *
 * Do not edit - automatically generated.
 */

// FRS_FRS()
template<typename __data_src_t>
bool FRS_FRS::__match(__data_src_t &__buffer)
{
  // MEMBER(DATA32 scalers[32] ZERO_SUPPRESS_LIST);
  // UINT32 no NOENCODE;
  uint32  no;
  MATCH_READ_FROM_BUFFER(215,uint32 ,no,14);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,FRS_FRS::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for FRS_FRS.
 *
 * Do not edit - automatically generated.
 */

// FRS_FRS()
template<typename __data_dest_t>
void PACKER_FRS_FRS::__packer(__data_dest_t &__buffer)
{
  // MEMBER(DATA32 scalers[32] ZERO_SUPPRESS_LIST);
  // UINT32 no NOENCODE;
  // if(((no & 0xffff0000) == 0x04400000))

  if (((no & 0xffff0000) == 0x04400000))
  {
    // list(0<=index<32)

    {
      // UINT32 ch_data NOENCODE;
      // ENCODE(scalers[index],(value=ch_data));

    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,FRS_FRS::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: FRS_MAIN
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for FRS_MAIN.
 *
 * Do not edit - automatically generated.
 */

// FRS_MAIN()
#if !PACKER_CODE
# define DECLARED_UNPACK_FRS_MAIN
class FRS_MAIN
#else//PACKER_CODE
# define DECLARED_PACKER_FRS_MAIN
class PACKER_FRS_MAIN
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA32 scalers[32] ZERO_SUPPRESS_LIST);
  raw_list_zero_suppress<DATA32,DATA32,32> scalers;
  // UINT32 no NOENCODE;
  // if((no == 0xbabababa))

    // UINT32 sc NOENCODE;
    // if(((sc & 0xffff0000) == 0x0c800000))

      // list(0<=index<32)

        // UINT32 ch_data NOENCODE;
        // ENCODE(scalers[index],(value=ch_data));


public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(FRS_MAIN);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for FRS_MAIN.
 *
 * Do not edit - automatically generated.
 */

// FRS_MAIN()
template<typename __data_src_t>
void FRS_MAIN::__unpack(__data_src_t &__buffer)
{
  // MEMBER(DATA32 scalers[32] ZERO_SUPPRESS_LIST);
  // UINT32 no NOENCODE;
  uint32  no;READ_FROM_BUFFER(196,uint32 ,no,15);
  // if((no == 0xbabababa))

  if ((no == 0xbabababa))
  {
    // UINT32 sc NOENCODE;
    uint32  sc;READ_FROM_BUFFER(200,uint32 ,sc,16);
    // if(((sc & 0xffff0000) == 0x0c800000))

    if (((sc & 0xffff0000) == 0x0c800000))
    {
      // list(0<=index<32)

      for (uint32 index = 0; index < (uint32) (32); ++index)
      {
        // UINT32 ch_data NOENCODE;
        uint32  ch_data;READ_FROM_BUFFER(205,uint32 ,ch_data,17);
        // ENCODE(scalers[index],(value=ch_data));

        {
          typedef __typeof__(*(&(scalers))) __array_t;
          typedef typename __array_t::item_t __item_t;
          __item_t &__item = scalers.insert_index(206,index);
          __item.value = ch_data;
        }
      }
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,FRS_MAIN::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for FRS_MAIN.
 *
 * Do not edit - automatically generated.
 */

// FRS_MAIN()
template<typename __data_src_t>
bool FRS_MAIN::__match(__data_src_t &__buffer)
{
  // MEMBER(DATA32 scalers[32] ZERO_SUPPRESS_LIST);
  // UINT32 no NOENCODE;
  uint32  no;
  MATCH_READ_FROM_BUFFER(196,uint32 ,no,18);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,FRS_MAIN::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for FRS_MAIN.
 *
 * Do not edit - automatically generated.
 */

// FRS_MAIN()
template<typename __data_dest_t>
void PACKER_FRS_MAIN::__packer(__data_dest_t &__buffer)
{
  // MEMBER(DATA32 scalers[32] ZERO_SUPPRESS_LIST);
  // UINT32 no NOENCODE;
  // if((no == 0xbabababa))

  if ((no == 0xbabababa))
  {
    // UINT32 sc NOENCODE;
    // if(((sc & 0xffff0000) == 0x0c800000))

    if (((sc & 0xffff0000) == 0x0c800000))
    {
      // list(0<=index<32)

      {
        // UINT32 ch_data NOENCODE;
        // ENCODE(scalers[index],(value=ch_data));

      }
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,FRS_MAIN::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: TIMESTAMP_WHITERABBIT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TIMESTAMP_WHITERABBIT.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT(id)
#if !PACKER_CODE
# define DECLARED_UNPACK_TIMESTAMP_WHITERABBIT
class TIMESTAMP_WHITERABBIT
#else//PACKER_CODE
# define DECLARED_PACKER_TIMESTAMP_WHITERABBIT
class PACKER_TIMESTAMP_WHITERABBIT
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA12 subsystem_id);
  DATA12 subsystem_id;
  // MEMBER(DATA16 t1);
  DATA16 t1;
  // MEMBER(DATA16 t2);
  DATA16 t2;
  // MEMBER(DATA16 t3);
  DATA16 t3;
  // MEMBER(DATA16 t4);
  DATA16 t4;
  // UINT32 header NOENCODE
  // {
    //  0_11: id = MATCH(id);
    // 12_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  // UINT32 d1 NOENCODE
  // {
    //  0_15: t1;
    // 16_31: 0x3e1;
    // ENCODE(t1,(value=t1));
  // }
  // UINT32 d2 NOENCODE
  // {
    //  0_15: t2;
    // 16_31: 0x4e1;
    // ENCODE(t2,(value=t2));
  // }
  // UINT32 d3 NOENCODE
  // {
    //  0_15: t3;
    // 16_31: 0x5e1;
    // ENCODE(t3,(value=t3));
  // }
  // UINT32 d4 NOENCODE
  // {
    //  0_15: t4;
    // 16_31: 0x6e1;
    // ENCODE(t4,(value=t4));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 id);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 id);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TIMESTAMP_WHITERABBIT);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TIMESTAMP_WHITERABBIT.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT(id)
template<typename __data_src_t>
void TIMESTAMP_WHITERABBIT::__unpack(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA12 subsystem_id);
  // MEMBER(DATA16 t1);
  // MEMBER(DATA16 t2);
  // MEMBER(DATA16 t3);
  // MEMBER(DATA16 t4);
  // UINT32 header NOENCODE
  // {
    //  0_11: id = MATCH(id);
    // 12_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 id : 12; // 0..11
      uint32 unnamed_12_15 : 4; // 12..15
      uint32 error_bit : 1; // 16
      uint32 unnamed_17_31 : 15; // 17..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_17_31 : 15; // 17..31
      uint32 error_bit : 1; // 16
      uint32 unnamed_12_15 : 4; // 12..15
      uint32 id : 12; // 0..11
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(277,uint32 ,header,header.u32,19);
  CHECK_BITS_EQUAL(272,header.id,id);
  CHECK_BITS_EQUAL(273,header.unnamed_12_15,0);
  CHECK_BITS_EQUAL(275,header.unnamed_17_31,0);
  {
    subsystem_id.value = header.id;
  }
  // UINT32 d1 NOENCODE
  // {
    //  0_15: t1;
    // 16_31: 0x3e1;
    // ENCODE(t1,(value=t1));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t1 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t1 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d1;
  READ_FROM_BUFFER_FULL(282,uint32 ,d1,d1.u32,20);
  CHECK_BITS_EQUAL(280,d1.unnamed_16_31,0x3e1);
  {
    t1.value = d1.t1;
  }
  // UINT32 d2 NOENCODE
  // {
    //  0_15: t2;
    // 16_31: 0x4e1;
    // ENCODE(t2,(value=t2));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t2 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t2 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d2;
  READ_FROM_BUFFER_FULL(287,uint32 ,d2,d2.u32,21);
  CHECK_BITS_EQUAL(285,d2.unnamed_16_31,0x4e1);
  {
    t2.value = d2.t2;
  }
  // UINT32 d3 NOENCODE
  // {
    //  0_15: t3;
    // 16_31: 0x5e1;
    // ENCODE(t3,(value=t3));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t3 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t3 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d3;
  READ_FROM_BUFFER_FULL(292,uint32 ,d3,d3.u32,22);
  CHECK_BITS_EQUAL(290,d3.unnamed_16_31,0x5e1);
  {
    t3.value = d3.t3;
  }
  // UINT32 d4 NOENCODE
  // {
    //  0_15: t4;
    // 16_31: 0x6e1;
    // ENCODE(t4,(value=t4));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t4 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t4 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d4;
  READ_FROM_BUFFER_FULL(297,uint32 ,d4,d4.u32,23);
  CHECK_BITS_EQUAL(295,d4.unnamed_16_31,0x6e1);
  {
    t4.value = d4.t4;
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TIMESTAMP_WHITERABBIT::__unpack,uint32 id);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TIMESTAMP_WHITERABBIT.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT(id)
template<typename __data_src_t>
bool TIMESTAMP_WHITERABBIT::__match(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA12 subsystem_id);
  // MEMBER(DATA16 t1);
  // MEMBER(DATA16 t2);
  // MEMBER(DATA16 t3);
  // MEMBER(DATA16 t4);
  // UINT32 header NOENCODE
  // {
    //  0_11: id = MATCH(id);
    // 12_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 id : 12; // 0..11
      uint32 unnamed_12_15 : 4; // 12..15
      uint32 error_bit : 1; // 16
      uint32 unnamed_17_31 : 15; // 17..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_17_31 : 15; // 17..31
      uint32 error_bit : 1; // 16
      uint32 unnamed_12_15 : 4; // 12..15
      uint32 id : 12; // 0..11
#endif
    };
    uint32  u32;
  } header;
  MATCH_READ_FROM_BUFFER_FULL(277,uint32 ,header,header.u32,24);
  MATCH_BITS_EQUAL(272,header.id,id);
  MATCH_BITS_EQUAL(273,header.unnamed_12_15,0);
  MATCH_BITS_EQUAL(275,header.unnamed_17_31,0);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,TIMESTAMP_WHITERABBIT::__match,uint32 id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TIMESTAMP_WHITERABBIT.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT(id)
template<typename __data_dest_t>
void PACKER_TIMESTAMP_WHITERABBIT::__packer(__data_dest_t &__buffer,uint32 id)
{
  // MEMBER(DATA12 subsystem_id);
  // MEMBER(DATA16 t1);
  // MEMBER(DATA16 t2);
  // MEMBER(DATA16 t3);
  // MEMBER(DATA16 t4);
  // UINT32 header NOENCODE
  // {
    //  0_11: id = MATCH(id);
    // 12_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  // UINT32 d1 NOENCODE
  // {
    //  0_15: t1;
    // 16_31: 0x3e1;
    // ENCODE(t1,(value=t1));
  // }
  // UINT32 d2 NOENCODE
  // {
    //  0_15: t2;
    // 16_31: 0x4e1;
    // ENCODE(t2,(value=t2));
  // }
  // UINT32 d3 NOENCODE
  // {
    //  0_15: t3;
    // 16_31: 0x5e1;
    // ENCODE(t3,(value=t3));
  // }
  // UINT32 d4 NOENCODE
  // {
    //  0_15: t4;
    // 16_31: 0x6e1;
    // ENCODE(t4,(value=t4));
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TIMESTAMP_WHITERABBIT::__packer,uint32 id);

/** END_PACKER ********************************************************/

//
// Generating code for: TIMESTAMP_WHITERABBIT_EXTENDED
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TIMESTAMP_WHITERABBIT_EXTENDED.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT_EXTENDED(id)
#if !PACKER_CODE
# define DECLARED_UNPACK_TIMESTAMP_WHITERABBIT_EXTENDED
class TIMESTAMP_WHITERABBIT_EXTENDED
#else//PACKER_CODE
# define DECLARED_PACKER_TIMESTAMP_WHITERABBIT_EXTENDED
class PACKER_TIMESTAMP_WHITERABBIT_EXTENDED
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA16 subsystem_id);
  DATA16 subsystem_id;
  // MEMBER(DATA16 t1);
  DATA16 t1;
  // MEMBER(DATA16 t2);
  DATA16 t2;
  // MEMBER(DATA16 t3);
  DATA16 t3;
  // MEMBER(DATA16 t4);
  DATA16 t4;
  // UINT32 header NOENCODE
  // {
    //  0_12: id = MATCH(id);
    // 13_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  // UINT32 d1 NOENCODE
  // {
    //  0_15: t1;
    // 16_31: 0x3e1;
    // ENCODE(t1,(value=t1));
  // }
  // UINT32 d2 NOENCODE
  // {
    //  0_15: t2;
    // 16_31: 0x4e1;
    // ENCODE(t2,(value=t2));
  // }
  // UINT32 d3 NOENCODE
  // {
    //  0_15: t3;
    // 16_31: 0x5e1;
    // ENCODE(t3,(value=t3));
  // }
  // UINT32 d4 NOENCODE
  // {
    //  0_15: t4;
    // 16_31: 0x6e1;
    // ENCODE(t4,(value=t4));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 id);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 id);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TIMESTAMP_WHITERABBIT_EXTENDED);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TIMESTAMP_WHITERABBIT_EXTENDED.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT_EXTENDED(id)
template<typename __data_src_t>
void TIMESTAMP_WHITERABBIT_EXTENDED::__unpack(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA16 subsystem_id);
  // MEMBER(DATA16 t1);
  // MEMBER(DATA16 t2);
  // MEMBER(DATA16 t3);
  // MEMBER(DATA16 t4);
  // UINT32 header NOENCODE
  // {
    //  0_12: id = MATCH(id);
    // 13_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 id : 13; // 0..12
      uint32 unnamed_13_15 : 3; // 13..15
      uint32 error_bit : 1; // 16
      uint32 unnamed_17_31 : 15; // 17..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_17_31 : 15; // 17..31
      uint32 error_bit : 1; // 16
      uint32 unnamed_13_15 : 3; // 13..15
      uint32 id : 13; // 0..12
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(314,uint32 ,header,header.u32,25);
  CHECK_BITS_EQUAL(309,header.id,id);
  CHECK_BITS_EQUAL(310,header.unnamed_13_15,0);
  CHECK_BITS_EQUAL(312,header.unnamed_17_31,0);
  {
    subsystem_id.value = header.id;
  }
  // UINT32 d1 NOENCODE
  // {
    //  0_15: t1;
    // 16_31: 0x3e1;
    // ENCODE(t1,(value=t1));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t1 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t1 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d1;
  READ_FROM_BUFFER_FULL(319,uint32 ,d1,d1.u32,26);
  CHECK_BITS_EQUAL(317,d1.unnamed_16_31,0x3e1);
  {
    t1.value = d1.t1;
  }
  // UINT32 d2 NOENCODE
  // {
    //  0_15: t2;
    // 16_31: 0x4e1;
    // ENCODE(t2,(value=t2));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t2 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t2 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d2;
  READ_FROM_BUFFER_FULL(324,uint32 ,d2,d2.u32,27);
  CHECK_BITS_EQUAL(322,d2.unnamed_16_31,0x4e1);
  {
    t2.value = d2.t2;
  }
  // UINT32 d3 NOENCODE
  // {
    //  0_15: t3;
    // 16_31: 0x5e1;
    // ENCODE(t3,(value=t3));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t3 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t3 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d3;
  READ_FROM_BUFFER_FULL(329,uint32 ,d3,d3.u32,28);
  CHECK_BITS_EQUAL(327,d3.unnamed_16_31,0x5e1);
  {
    t3.value = d3.t3;
  }
  // UINT32 d4 NOENCODE
  // {
    //  0_15: t4;
    // 16_31: 0x6e1;
    // ENCODE(t4,(value=t4));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t4 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t4 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d4;
  READ_FROM_BUFFER_FULL(334,uint32 ,d4,d4.u32,29);
  CHECK_BITS_EQUAL(332,d4.unnamed_16_31,0x6e1);
  {
    t4.value = d4.t4;
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TIMESTAMP_WHITERABBIT_EXTENDED::__unpack,uint32 id);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TIMESTAMP_WHITERABBIT_EXTENDED.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT_EXTENDED(id)
template<typename __data_src_t>
bool TIMESTAMP_WHITERABBIT_EXTENDED::__match(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA16 subsystem_id);
  // MEMBER(DATA16 t1);
  // MEMBER(DATA16 t2);
  // MEMBER(DATA16 t3);
  // MEMBER(DATA16 t4);
  // UINT32 header NOENCODE
  // {
    //  0_12: id = MATCH(id);
    // 13_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 id : 13; // 0..12
      uint32 unnamed_13_15 : 3; // 13..15
      uint32 error_bit : 1; // 16
      uint32 unnamed_17_31 : 15; // 17..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_17_31 : 15; // 17..31
      uint32 error_bit : 1; // 16
      uint32 unnamed_13_15 : 3; // 13..15
      uint32 id : 13; // 0..12
#endif
    };
    uint32  u32;
  } header;
  MATCH_READ_FROM_BUFFER_FULL(314,uint32 ,header,header.u32,30);
  MATCH_BITS_EQUAL(309,header.id,id);
  MATCH_BITS_EQUAL(310,header.unnamed_13_15,0);
  MATCH_BITS_EQUAL(312,header.unnamed_17_31,0);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,TIMESTAMP_WHITERABBIT_EXTENDED::__match,uint32 id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TIMESTAMP_WHITERABBIT_EXTENDED.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT_EXTENDED(id)
template<typename __data_dest_t>
void PACKER_TIMESTAMP_WHITERABBIT_EXTENDED::__packer(__data_dest_t &__buffer,uint32 id)
{
  // MEMBER(DATA16 subsystem_id);
  // MEMBER(DATA16 t1);
  // MEMBER(DATA16 t2);
  // MEMBER(DATA16 t3);
  // MEMBER(DATA16 t4);
  // UINT32 header NOENCODE
  // {
    //  0_12: id = MATCH(id);
    // 13_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  // UINT32 d1 NOENCODE
  // {
    //  0_15: t1;
    // 16_31: 0x3e1;
    // ENCODE(t1,(value=t1));
  // }
  // UINT32 d2 NOENCODE
  // {
    //  0_15: t2;
    // 16_31: 0x4e1;
    // ENCODE(t2,(value=t2));
  // }
  // UINT32 d3 NOENCODE
  // {
    //  0_15: t3;
    // 16_31: 0x5e1;
    // ENCODE(t3,(value=t3));
  // }
  // UINT32 d4 NOENCODE
  // {
    //  0_15: t4;
    // 16_31: 0x6e1;
    // ENCODE(t4,(value=t4));
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TIMESTAMP_WHITERABBIT_EXTENDED::__packer,uint32 id);

/** END_PACKER ********************************************************/

//
// Generating code for: TRLOII_TPAT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TRLOII_TPAT.
 *
 * Do not edit - automatically generated.
 */

// TRLOII_TPAT(id)
#if !PACKER_CODE
# define DECLARED_UNPACK_TRLOII_TPAT
class TRLOII_TPAT
#else//PACKER_CODE
# define DECLARED_PACKER_TRLOII_TPAT
class PACKER_TRLOII_TPAT
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA32 n);
  DATA32 n;
  // MEMBER(DATA32 tpat[170] NO_INDEX_LIST);
  raw_list_ii_zero_suppress<DATA32,DATA32,170> tpat;
  // MEMBER(DATA8 trig[170] NO_INDEX_LIST);
  raw_list_ii_zero_suppress<DATA8,DATA8,170> trig;
  // MEMBER(DATA32 ts_lo[170] NO_INDEX_LIST);
  raw_list_ii_zero_suppress<DATA32,DATA32,170> ts_lo;
  // MEMBER(DATA32 ts_hi[170] NO_INDEX_LIST);
  raw_list_ii_zero_suppress<DATA32,DATA32,170> ts_hi;
  // UINT32 header NOENCODE
  // {
    //  0_11: uint32_num;
    // 12_23: event_num;
    // 24_31: id = MATCH(id);
    // ENCODE(n,(value=(uint32_num / 3)));
  // }
  // list(0<=index<(header.uint32_num / 3))

    // UINT32 time_lo NOENCODE
    // {
      //  0_31: t;
      // ENCODE(ts_lo APPEND_LIST,(value=t));
    // }
    // UINT32 time_hi NOENCODE
    // {
      //  0_30: t;
      //    31: overflow;
      // ENCODE(ts_hi APPEND_LIST,(value=t));
    // }
    // UINT32 trigger NOENCODE
    // {
      //  0_23: tpat;
      // 24_27: encoded;
      // 28_31: lec;
      // ENCODE(tpat APPEND_LIST,(value=tpat));
      // ENCODE(trig APPEND_LIST,(value=encoded));
    // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 id);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 id);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TRLOII_TPAT);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TRLOII_TPAT.
 *
 * Do not edit - automatically generated.
 */

// TRLOII_TPAT(id)
template<typename __data_src_t>
void TRLOII_TPAT::__unpack(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA32 n);
  // MEMBER(DATA32 tpat[170] NO_INDEX_LIST);
  // MEMBER(DATA8 trig[170] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_lo[170] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_hi[170] NO_INDEX_LIST);
  // UINT32 header NOENCODE
  // {
    //  0_11: uint32_num;
    // 12_23: event_num;
    // 24_31: id = MATCH(id);
    // ENCODE(n,(value=(uint32_num / 3)));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 uint32_num : 12; // 0..11
      uint32 event_num : 12; // 12..23
      uint32 id : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 id : 8; // 24..31
      uint32 event_num : 12; // 12..23
      uint32 uint32_num : 12; // 0..11
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(240,uint32 ,header,header.u32,31);
  CHECK_BITS_EQUAL(238,header.id,id);
  {
    n.value = (header.uint32_num / 3);
  }
  // list(0<=index<(header.uint32_num / 3))

  for (uint32 index = 0; index < (uint32) ((header.uint32_num / 3)); ++index)
  {
    // UINT32 time_lo NOENCODE
    // {
      //  0_31: t;
      // ENCODE(ts_lo APPEND_LIST,(value=t));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 t : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 t : 32; // 0..31
#endif
      };
      uint32  u32;
    } time_lo;
    READ_FROM_BUFFER_FULL(246,uint32 ,time_lo,time_lo.u32,32);
    {
      typedef __typeof__(*(&(ts_lo))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = ts_lo.append_item(245);
      __item.value = time_lo.t;
    }
    // UINT32 time_hi NOENCODE
    // {
      //  0_30: t;
      //    31: overflow;
      // ENCODE(ts_hi APPEND_LIST,(value=t));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 t : 31; // 0..30
        uint32 overflow : 1; // 31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 overflow : 1; // 31
        uint32 t : 31; // 0..30
#endif
      };
      uint32  u32;
    } time_hi;
    READ_FROM_BUFFER_FULL(251,uint32 ,time_hi,time_hi.u32,33);
    {
      typedef __typeof__(*(&(ts_hi))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = ts_hi.append_item(250);
      __item.value = time_hi.t;
    }
    // UINT32 trigger NOENCODE
    // {
      //  0_23: tpat;
      // 24_27: encoded;
      // 28_31: lec;
      // ENCODE(tpat APPEND_LIST,(value=tpat));
      // ENCODE(trig APPEND_LIST,(value=encoded));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 tpat : 24; // 0..23
        uint32 encoded : 4; // 24..27
        uint32 lec : 4; // 28..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 lec : 4; // 28..31
        uint32 encoded : 4; // 24..27
        uint32 tpat : 24; // 0..23
#endif
      };
      uint32  u32;
    } trigger;
    READ_FROM_BUFFER_FULL(258,uint32 ,trigger,trigger.u32,34);
    {
      {
        typedef __typeof__(*(&(tpat))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = tpat.append_item(256);
        __item.value = trigger.tpat;
      }
      {
        typedef __typeof__(*(&(trig))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = trig.append_item(257);
        __item.value = trigger.encoded;
      }
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TRLOII_TPAT::__unpack,uint32 id);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TRLOII_TPAT.
 *
 * Do not edit - automatically generated.
 */

// TRLOII_TPAT(id)
template<typename __data_src_t>
bool TRLOII_TPAT::__match(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA32 n);
  // MEMBER(DATA32 tpat[170] NO_INDEX_LIST);
  // MEMBER(DATA8 trig[170] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_lo[170] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_hi[170] NO_INDEX_LIST);
  // UINT32 header NOENCODE
  // {
    //  0_11: uint32_num;
    // 12_23: event_num;
    // 24_31: id = MATCH(id);
    // ENCODE(n,(value=(uint32_num / 3)));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 uint32_num : 12; // 0..11
      uint32 event_num : 12; // 12..23
      uint32 id : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 id : 8; // 24..31
      uint32 event_num : 12; // 12..23
      uint32 uint32_num : 12; // 0..11
#endif
    };
    uint32  u32;
  } header;
  MATCH_READ_FROM_BUFFER_FULL(240,uint32 ,header,header.u32,35);
  MATCH_BITS_EQUAL(238,header.id,id);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,TRLOII_TPAT::__match,uint32 id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TRLOII_TPAT.
 *
 * Do not edit - automatically generated.
 */

// TRLOII_TPAT(id)
template<typename __data_dest_t>
void PACKER_TRLOII_TPAT::__packer(__data_dest_t &__buffer,uint32 id)
{
  // MEMBER(DATA32 n);
  // MEMBER(DATA32 tpat[170] NO_INDEX_LIST);
  // MEMBER(DATA8 trig[170] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_lo[170] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_hi[170] NO_INDEX_LIST);
  // UINT32 header NOENCODE
  // {
    //  0_11: uint32_num;
    // 12_23: event_num;
    // 24_31: id = MATCH(id);
    // ENCODE(n,(value=(uint32_num / 3)));
  // }
  // list(0<=index<(header.uint32_num / 3))

  {
    // UINT32 time_lo NOENCODE
    // {
      //  0_31: t;
      // ENCODE(ts_lo APPEND_LIST,(value=t));
    // }
    // UINT32 time_hi NOENCODE
    // {
      //  0_30: t;
      //    31: overflow;
      // ENCODE(ts_hi APPEND_LIST,(value=t));
    // }
    // UINT32 trigger NOENCODE
    // {
      //  0_23: tpat;
      // 24_27: encoded;
      // 28_31: lec;
      // ENCODE(tpat APPEND_LIST,(value=tpat));
      // ENCODE(trig APPEND_LIST,(value=encoded));
    // }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TRLOII_TPAT::__packer,uint32 id);

/** END_PACKER ********************************************************/

//
// Generating code for: WR_MULTI
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for WR_MULTI.
 *
 * Do not edit - automatically generated.
 */

// WR_MULTI()
#if !PACKER_CODE
# define DECLARED_UNPACK_WR_MULTI
class WR_MULTI
#else//PACKER_CODE
# define DECLARED_PACKER_WR_MULTI
class PACKER_WR_MULTI
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA32 time_hi);
  DATA32 time_hi;
  // MEMBER(DATA32 time_lo);
  DATA32 time_lo;
  // UINT32 hi NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_hi,(value=time));
  // }
  // UINT32 lo NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_lo,(value=time));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(WR_MULTI);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for WR_MULTI.
 *
 * Do not edit - automatically generated.
 */

// WR_MULTI()
template<typename __data_src_t>
void WR_MULTI::__unpack(__data_src_t &__buffer)
{
  // MEMBER(DATA32 time_hi);
  // MEMBER(DATA32 time_lo);
  // UINT32 hi NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_hi,(value=time));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 time : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 time : 32; // 0..31
#endif
    };
    uint32  u32;
  } hi;
  READ_FROM_BUFFER_FULL(345,uint32 ,hi,hi.u32,36);
  {
    time_hi.value = hi.time;
  }
  // UINT32 lo NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_lo,(value=time));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 time : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 time : 32; // 0..31
#endif
    };
    uint32  u32;
  } lo;
  READ_FROM_BUFFER_FULL(349,uint32 ,lo,lo.u32,37);
  {
    time_lo.value = lo.time;
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,WR_MULTI::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for WR_MULTI.
 *
 * Do not edit - automatically generated.
 */

// WR_MULTI()
template<typename __data_src_t>
bool WR_MULTI::__match(__data_src_t &__buffer)
{
  // MEMBER(DATA32 time_hi);
  // MEMBER(DATA32 time_lo);
  // UINT32 hi NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_hi,(value=time));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 time : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 time : 32; // 0..31
#endif
    };
    uint32  u32;
  } hi;
  MATCH_READ_FROM_BUFFER_FULL(345,uint32 ,hi,hi.u32,38);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,WR_MULTI::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for WR_MULTI.
 *
 * Do not edit - automatically generated.
 */

// WR_MULTI()
template<typename __data_dest_t>
void PACKER_WR_MULTI::__packer(__data_dest_t &__buffer)
{
  // MEMBER(DATA32 time_hi);
  // MEMBER(DATA32 time_lo);
  // UINT32 hi NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_hi,(value=time));
  // }
  // UINT32 lo NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_lo,(value=time));
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,WR_MULTI::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: aida_subev
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for aida_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(aida_subev)
#if !PACKER_CODE
# define DECLARED_UNPACK_aida_subev
class aida_subev
#else//PACKER_CODE
# define DECLARED_PACKER_aida_subev
class PACKER_aida_subev
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // ts = TIMESTAMP_WHITERABBIT(id=0x700);
  // external data = EXT_AIDA();
  SINGLE(TIMESTAMP_WHITERABBIT,ts);
  SINGLE(EXT_AIDA,data);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(aida_subev);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for aida_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(aida_subev)
template<typename __data_src_t>
void aida_subev::__unpack(__data_src_t &__buffer)
{
  // ts = TIMESTAMP_WHITERABBIT(id=0x700);
  UNPACK_DECL(365,TIMESTAMP_WHITERABBIT,ts,/*id*/0x700);
  // external data = EXT_AIDA();
  UNPACK_DECL(366,EXT_AIDA,data);
}
FORCE_IMPL_DATA_SRC_FCN(void,aida_subev::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for aida_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(aida_subev)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for aida_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(aida_subev)
template<typename __data_dest_t>
void PACKER_aida_subev::__packer(__data_dest_t &__buffer)
{
  // ts = TIMESTAMP_WHITERABBIT(id=0x700);
  PACK_DECL(365,TIMESTAMP_WHITERABBIT,ts,/*id*/0x700);
  // external data = EXT_AIDA();
  PACK_DECL(366,EXT_AIDA,data);
}
FORCE_IMPL_DATA_SRC_FCN(void,aida_subev::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: fatima_tamex_subev
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for fatima_tamex_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(fatima_tamex_subev)
#if !PACKER_CODE
# define DECLARED_UNPACK_fatima_tamex_subev
class fatima_tamex_subev
#else//PACKER_CODE
# define DECLARED_PACKER_fatima_tamex_subev
class PACKER_fatima_tamex_subev
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // ts = TIMESTAMP_WHITERABBIT_EXTENDED(id=0x1600);
  // external data = EXT_FATIMA_TAMEX();
  SINGLE(TIMESTAMP_WHITERABBIT_EXTENDED,ts);
  SINGLE(EXT_FATIMA_TAMEX,data);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(fatima_tamex_subev);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for fatima_tamex_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(fatima_tamex_subev)
template<typename __data_src_t>
void fatima_tamex_subev::__unpack(__data_src_t &__buffer)
{
  // ts = TIMESTAMP_WHITERABBIT_EXTENDED(id=0x1600);
  UNPACK_DECL(395,TIMESTAMP_WHITERABBIT_EXTENDED,ts,/*id*/0x1600);
  // external data = EXT_FATIMA_TAMEX();
  UNPACK_DECL(396,EXT_FATIMA_TAMEX,data);
}
FORCE_IMPL_DATA_SRC_FCN(void,fatima_tamex_subev::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for fatima_tamex_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(fatima_tamex_subev)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for fatima_tamex_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(fatima_tamex_subev)
template<typename __data_dest_t>
void PACKER_fatima_tamex_subev::__packer(__data_dest_t &__buffer)
{
  // ts = TIMESTAMP_WHITERABBIT_EXTENDED(id=0x1600);
  PACK_DECL(395,TIMESTAMP_WHITERABBIT_EXTENDED,ts,/*id*/0x1600);
  // external data = EXT_FATIMA_TAMEX();
  PACK_DECL(396,EXT_FATIMA_TAMEX,data);
}
FORCE_IMPL_DATA_SRC_FCN(void,fatima_tamex_subev::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: fatima_vme_subev
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for fatima_vme_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(fatima_vme_subev)
#if !PACKER_CODE
# define DECLARED_UNPACK_fatima_vme_subev
class fatima_vme_subev
#else//PACKER_CODE
# define DECLARED_PACKER_fatima_vme_subev
class PACKER_fatima_vme_subev
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // ts = TIMESTAMP_WHITERABBIT_EXTENDED(id=0x1500);
  // external data = EXT_FATIMA_VME();
  SINGLE(TIMESTAMP_WHITERABBIT_EXTENDED,ts);
  SINGLE(EXT_FATIMA_VME,data);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(fatima_vme_subev);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for fatima_vme_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(fatima_vme_subev)
template<typename __data_src_t>
void fatima_vme_subev::__unpack(__data_src_t &__buffer)
{
  // ts = TIMESTAMP_WHITERABBIT_EXTENDED(id=0x1500);
  UNPACK_DECL(388,TIMESTAMP_WHITERABBIT_EXTENDED,ts,/*id*/0x1500);
  // external data = EXT_FATIMA_VME();
  UNPACK_DECL(390,EXT_FATIMA_VME,data);
}
FORCE_IMPL_DATA_SRC_FCN(void,fatima_vme_subev::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for fatima_vme_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(fatima_vme_subev)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for fatima_vme_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(fatima_vme_subev)
template<typename __data_dest_t>
void PACKER_fatima_vme_subev::__packer(__data_dest_t &__buffer)
{
  // ts = TIMESTAMP_WHITERABBIT_EXTENDED(id=0x1500);
  PACK_DECL(388,TIMESTAMP_WHITERABBIT_EXTENDED,ts,/*id*/0x1500);
  // external data = EXT_FATIMA_VME();
  PACK_DECL(390,EXT_FATIMA_VME,data);
}
FORCE_IMPL_DATA_SRC_FCN(void,fatima_vme_subev::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: frs_frs_subev
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for frs_frs_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_frs_subev)
#if !PACKER_CODE
# define DECLARED_UNPACK_frs_frs_subev
class frs_frs_subev
#else//PACKER_CODE
# define DECLARED_PACKER_frs_frs_subev
class PACKER_frs_frs_subev
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // select several

    // subev = FRS_FRS();
  SINGLE(FRS_FRS,subev);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(frs_frs_subev);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for frs_frs_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_frs_subev)
template<typename __data_src_t>
void frs_frs_subev::__unpack(__data_src_t &__buffer)
{
  // select several

    // subev = FRS_FRS();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: FRS_FRS subev: (s32)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(435,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 1
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(434,FRS_FRS,subev);
        break;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,frs_frs_subev::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for frs_frs_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_frs_subev)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for frs_frs_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_frs_subev)
template<typename __data_dest_t>
void PACKER_frs_frs_subev::__packer(__data_dest_t &__buffer)
{
  // select several

    // subev = FRS_FRS();
  {
    PACK_DECL(434,FRS_FRS,subev);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,frs_frs_subev::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: frs_main_subev
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for frs_main_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_main_subev)
#if !PACKER_CODE
# define DECLARED_UNPACK_frs_main_subev
class frs_main_subev
#else//PACKER_CODE
# define DECLARED_PACKER_frs_main_subev
class PACKER_frs_main_subev
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // select several

    // subev = FRS_MAIN();
  SINGLE(FRS_MAIN,subev);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(frs_main_subev);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for frs_main_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_main_subev)
template<typename __data_src_t>
void frs_main_subev::__unpack(__data_src_t &__buffer)
{
  // select several

    // subev = FRS_MAIN();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: FRS_MAIN subev: (s32)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(411,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 1
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(410,FRS_MAIN,subev);
        break;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,frs_main_subev::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for frs_main_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_main_subev)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for frs_main_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_main_subev)
template<typename __data_dest_t>
void PACKER_frs_main_subev::__packer(__data_dest_t &__buffer)
{
  // select several

    // subev = FRS_MAIN();
  {
    PACK_DECL(410,FRS_MAIN,subev);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,frs_main_subev::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: frs_subev1
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for frs_subev1.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_subev1)
#if !PACKER_CODE
# define DECLARED_UNPACK_frs_subev1
class frs_subev1
#else//PACKER_CODE
# define DECLARED_PACKER_frs_subev1
class PACKER_frs_subev1
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // ts = TIMESTAMP_WHITERABBIT(id=0x100);
  // subev = FRS();
  SINGLE(TIMESTAMP_WHITERABBIT,ts);
  SINGLE(FRS,subev);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(frs_subev1);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for frs_subev1.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_subev1)
template<typename __data_src_t>
void frs_subev1::__unpack(__data_src_t &__buffer)
{
  // ts = TIMESTAMP_WHITERABBIT(id=0x100);
  UNPACK_DECL(401,TIMESTAMP_WHITERABBIT,ts,/*id*/0x100);
  // subev = FRS();
  UNPACK_DECL(402,FRS,subev);
}
FORCE_IMPL_DATA_SRC_FCN(void,frs_subev1::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for frs_subev1.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_subev1)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for frs_subev1.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_subev1)
template<typename __data_dest_t>
void PACKER_frs_subev1::__packer(__data_dest_t &__buffer)
{
  // ts = TIMESTAMP_WHITERABBIT(id=0x100);
  PACK_DECL(401,TIMESTAMP_WHITERABBIT,ts,/*id*/0x100);
  // subev = FRS();
  PACK_DECL(402,FRS,subev);
}
FORCE_IMPL_DATA_SRC_FCN(void,frs_subev1::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: frs_subev4
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for frs_subev4.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_subev4)
#if !PACKER_CODE
# define DECLARED_UNPACK_frs_subev4
class frs_subev4
#else//PACKER_CODE
# define DECLARED_PACKER_frs_subev4
class PACKER_frs_subev4
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // ts = TIMESTAMP_WHITERABBIT(id=0x100);
  // subev = FRS();
  SINGLE(TIMESTAMP_WHITERABBIT,ts);
  SINGLE(FRS,subev);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(frs_subev4);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for frs_subev4.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_subev4)
template<typename __data_src_t>
void frs_subev4::__unpack(__data_src_t &__buffer)
{
  // ts = TIMESTAMP_WHITERABBIT(id=0x100);
  UNPACK_DECL(425,TIMESTAMP_WHITERABBIT,ts,/*id*/0x100);
  // subev = FRS();
  UNPACK_DECL(426,FRS,subev);
}
FORCE_IMPL_DATA_SRC_FCN(void,frs_subev4::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for frs_subev4.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_subev4)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for frs_subev4.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_subev4)
template<typename __data_dest_t>
void PACKER_frs_subev4::__packer(__data_dest_t &__buffer)
{
  // ts = TIMESTAMP_WHITERABBIT(id=0x100);
  PACK_DECL(425,TIMESTAMP_WHITERABBIT,ts,/*id*/0x100);
  // subev = FRS();
  PACK_DECL(426,FRS,subev);
}
FORCE_IMPL_DATA_SRC_FCN(void,frs_subev4::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: frs_subev6
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for frs_subev6.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_subev6)
#if !PACKER_CODE
# define DECLARED_UNPACK_frs_subev6
class frs_subev6
#else//PACKER_CODE
# define DECLARED_PACKER_frs_subev6
class PACKER_frs_subev6
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // ts = TIMESTAMP_WHITERABBIT(id=0x100);
  // subev = FRS();
  SINGLE(TIMESTAMP_WHITERABBIT,ts);
  SINGLE(FRS,subev);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(frs_subev6);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for frs_subev6.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_subev6)
template<typename __data_src_t>
void frs_subev6::__unpack(__data_src_t &__buffer)
{
  // ts = TIMESTAMP_WHITERABBIT(id=0x100);
  UNPACK_DECL(440,TIMESTAMP_WHITERABBIT,ts,/*id*/0x100);
  // subev = FRS();
  UNPACK_DECL(441,FRS,subev);
}
FORCE_IMPL_DATA_SRC_FCN(void,frs_subev6::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for frs_subev6.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_subev6)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for frs_subev6.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_subev6)
template<typename __data_dest_t>
void PACKER_frs_subev6::__packer(__data_dest_t &__buffer)
{
  // ts = TIMESTAMP_WHITERABBIT(id=0x100);
  PACK_DECL(440,TIMESTAMP_WHITERABBIT,ts,/*id*/0x100);
  // subev = FRS();
  PACK_DECL(441,FRS,subev);
}
FORCE_IMPL_DATA_SRC_FCN(void,frs_subev6::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: frs_tpat_subev
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for frs_tpat_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_tpat_subev)
#if !PACKER_CODE
# define DECLARED_UNPACK_frs_tpat_subev
class frs_tpat_subev
#else//PACKER_CODE
# define DECLARED_PACKER_frs_tpat_subev
class PACKER_frs_tpat_subev
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // dummy = DUMMY();
  // tpat = TRLOII_TPAT(id=207);
  SINGLE(DUMMY,dummy);
  SINGLE(TRLOII_TPAT,tpat);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(frs_tpat_subev);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for frs_tpat_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_tpat_subev)
template<typename __data_src_t>
void frs_tpat_subev::__unpack(__data_src_t &__buffer)
{
  // dummy = DUMMY();
  UNPACK_DECL(419,DUMMY,dummy);
  // tpat = TRLOII_TPAT(id=207);
  UNPACK_DECL(420,TRLOII_TPAT,tpat,/*id*/207);
}
FORCE_IMPL_DATA_SRC_FCN(void,frs_tpat_subev::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for frs_tpat_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_tpat_subev)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for frs_tpat_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_tpat_subev)
template<typename __data_dest_t>
void PACKER_frs_tpat_subev::__packer(__data_dest_t &__buffer)
{
  // dummy = DUMMY();
  PACK_DECL(419,DUMMY,dummy);
  // tpat = TRLOII_TPAT(id=207);
  PACK_DECL(420,TRLOII_TPAT,tpat,/*id*/207);
}
FORCE_IMPL_DATA_SRC_FCN(void,frs_tpat_subev::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: germanium_subev
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for germanium_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(germanium_subev)
#if !PACKER_CODE
# define DECLARED_UNPACK_germanium_subev
class germanium_subev
#else//PACKER_CODE
# define DECLARED_PACKER_germanium_subev
class PACKER_germanium_subev
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // ts = TIMESTAMP_WHITERABBIT(id=0x400);
  // external data = EXT_GERMANIUM();
  SINGLE(TIMESTAMP_WHITERABBIT,ts);
  SINGLE(EXT_GERMANIUM,data);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(germanium_subev);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for germanium_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(germanium_subev)
template<typename __data_src_t>
void germanium_subev::__unpack(__data_src_t &__buffer)
{
  // ts = TIMESTAMP_WHITERABBIT(id=0x400);
  UNPACK_DECL(372,TIMESTAMP_WHITERABBIT,ts,/*id*/0x400);
  // external data = EXT_GERMANIUM();
  UNPACK_DECL(374,EXT_GERMANIUM,data);
}
FORCE_IMPL_DATA_SRC_FCN(void,germanium_subev::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for germanium_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(germanium_subev)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for germanium_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(germanium_subev)
template<typename __data_dest_t>
void PACKER_germanium_subev::__packer(__data_dest_t &__buffer)
{
  // ts = TIMESTAMP_WHITERABBIT(id=0x400);
  PACK_DECL(372,TIMESTAMP_WHITERABBIT,ts,/*id*/0x400);
  // external data = EXT_GERMANIUM();
  PACK_DECL(374,EXT_GERMANIUM,data);
}
FORCE_IMPL_DATA_SRC_FCN(void,germanium_subev::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: plastic_subev
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for plastic_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(plastic_subev)
#if !PACKER_CODE
# define DECLARED_UNPACK_plastic_subev
class plastic_subev
#else//PACKER_CODE
# define DECLARED_PACKER_plastic_subev
class PACKER_plastic_subev
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // ts = TIMESTAMP_WHITERABBIT(id=0x500);
  SINGLE(TIMESTAMP_WHITERABBIT,ts);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(plastic_subev);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for plastic_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(plastic_subev)
template<typename __data_src_t>
void plastic_subev::__unpack(__data_src_t &__buffer)
{
  // ts = TIMESTAMP_WHITERABBIT(id=0x500);
  UNPACK_DECL(381,TIMESTAMP_WHITERABBIT,ts,/*id*/0x500);
}
FORCE_IMPL_DATA_SRC_FCN(void,plastic_subev::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for plastic_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(plastic_subev)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for plastic_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(plastic_subev)
template<typename __data_dest_t>
void PACKER_plastic_subev::__packer(__data_dest_t &__buffer)
{
  // ts = TIMESTAMP_WHITERABBIT(id=0x500);
  PACK_DECL(381,TIMESTAMP_WHITERABBIT,ts,/*id*/0x500);
}
FORCE_IMPL_DATA_SRC_FCN(void,plastic_subev::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for EVENT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for EVENT.
 *
 * Do not edit - automatically generated.
 */

// EVENT
class unpack_event : public unpack_event_base
{
public:
  // germanium = germanium_subev(type=10,subtype=1,procid=60,control=20,
                              // subcrate=0);
  // fatima_vme = fatima_vme_subev(type=10,subtype=1,procid=70,control=20,
                                // subcrate=0);
  // fatima_tamex = fatima_tamex_subev(type=10,subtype=1,procid=75,control=20,
                                    // subcrate=0);
  // aida = aida_subev(type=10,subtype=1,procid=90,control=37,subcrate=0);
  // frs_main = frs_main_subev(type=12,subtype=1,procid=10,control=20,
                            // subcrate=0);
  // frs_tpat = frs_tpat_subev(type=36,subtype=0xe10,procid=10,control=20,
                            // subcrate=0);
  // frs_frs = frs_frs_subev(type=12,subtype=1,procid=30,control=20,
                          // subcrate=0);
  // ignore_unknown_subevent;
SINGLE(germanium_subev,germanium);
SINGLE(fatima_vme_subev,fatima_vme);
SINGLE(fatima_tamex_subev,fatima_tamex);
SINGLE(aida_subev,aida);
SINGLE(frs_main_subev,frs_main);
SINGLE(frs_tpat_subev,frs_tpat);
SINGLE(frs_frs_subev,frs_frs);
public:
#ifndef __PSDC__
  bitsone<8> __visited;
  void __clear_visited() { __visited.clear(); }
  bool ignore_unknown_subevent() { return true; }
#endif//!__PSDC__

public:
#ifndef __PSDC__
template<typename __data_src_t>
  int __unpack_subevent(subevent_header *__header,__data_src_t &__buffer);
  int __revoke_subevent(subevent_header *__header);
  // void __clean_event();

  STRUCT_FCNS_DECL(unpack_event);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for EVENT.
 *
 * Do not edit - automatically generated.
 */

// EVENT
template<typename __data_src_t>
int unpack_event::__unpack_subevent(subevent_header *__header,__data_src_t &__buffer)
  // germanium = germanium_subev(type=10,subtype=1,procid=60,control=20,
                              // subcrate=0);
  // fatima_vme = fatima_vme_subev(type=10,subtype=1,procid=70,control=20,
                                // subcrate=0);
  // fatima_tamex = fatima_tamex_subev(type=10,subtype=1,procid=75,control=20,
                                    // subcrate=0);
  // aida = aida_subev(type=10,subtype=1,procid=90,control=37,subcrate=0);
  // frs_main = frs_main_subev(type=12,subtype=1,procid=10,control=20,
                            // subcrate=0);
  // frs_tpat = frs_tpat_subev(type=36,subtype=0xe10,procid=10,control=20,
                            // subcrate=0);
  // frs_frs = frs_frs_subev(type=12,subtype=1,procid=30,control=20,
                          // subcrate=0);
  // ignore_unknown_subevent;
{
  int __match_no = 0;
  MATCH_SUBEVENT_DECL(451,__match_no,1,((VES10_1_type==10)&&(VES10_1_subtype==1)&&(VES10_1_control==20)&&(VES10_1_subcrate==0)&&(VES10_1_procid==60)),germanium);
  MATCH_SUBEVENT_DECL(453,__match_no,2,((VES10_1_type==10)&&(VES10_1_subtype==1)&&(VES10_1_control==20)&&(VES10_1_subcrate==0)&&(VES10_1_procid==70)),fatima_vme);
  MATCH_SUBEVENT_DECL(454,__match_no,3,((VES10_1_type==10)&&(VES10_1_subtype==1)&&(VES10_1_control==20)&&(VES10_1_subcrate==0)&&(VES10_1_procid==75)),fatima_tamex);
  MATCH_SUBEVENT_DECL(455,__match_no,4,((VES10_1_type==10)&&(VES10_1_subtype==1)&&(VES10_1_control==37)&&(VES10_1_subcrate==0)&&(VES10_1_procid==90)),aida);
  MATCH_SUBEVENT_DECL(459,__match_no,5,((VES10_1_type==12)&&(VES10_1_subtype==1)&&(VES10_1_control==20)&&(VES10_1_subcrate==0)&&(VES10_1_procid==10)),frs_main);
  MATCH_SUBEVENT_DECL(460,__match_no,6,((VES10_1_type==36)&&(VES10_1_subtype==0xe10)&&(VES10_1_control==20)&&(VES10_1_subcrate==0)&&(VES10_1_procid==10)),frs_tpat);
  MATCH_SUBEVENT_DECL(462,__match_no,7,((VES10_1_type==12)&&(VES10_1_subtype==1)&&(VES10_1_control==20)&&(VES10_1_subcrate==0)&&(VES10_1_procid==30)),frs_frs);
  if (!__match_no) return 0;
  switch (__match_no)
  {
    case 1:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(451,germanium_subev,germanium,0);
      UNPACK_SUBEVENT_DECL(451,0,germanium_subev,germanium);
      break;
    case 2:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(453,fatima_vme_subev,fatima_vme,1);
      UNPACK_SUBEVENT_DECL(453,0,fatima_vme_subev,fatima_vme);
      break;
    case 3:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(454,fatima_tamex_subev,fatima_tamex,2);
      UNPACK_SUBEVENT_DECL(454,0,fatima_tamex_subev,fatima_tamex);
      break;
    case 4:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(455,aida_subev,aida,3);
      UNPACK_SUBEVENT_DECL(455,0,aida_subev,aida);
      break;
    case 5:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(459,frs_main_subev,frs_main,4);
      UNPACK_SUBEVENT_DECL(459,0,frs_main_subev,frs_main);
      break;
    case 6:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(460,frs_tpat_subev,frs_tpat,5);
      UNPACK_SUBEVENT_DECL(460,0,frs_tpat_subev,frs_tpat);
      break;
    case 7:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(462,frs_frs_subev,frs_frs,6);
      UNPACK_SUBEVENT_DECL(462,0,frs_frs_subev,frs_frs);
      break;
  }
  return 0;
}
FORCE_IMPL_DATA_SRC_FCN_HDR(int,unpack_event::__unpack_subevent);

/** END_UNPACKER ******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for EVENT.
 *
 * Do not edit - automatically generated.
 */

// EVENT
  // germanium = germanium_subev(type=10,subtype=1,procid=60,control=20,
                              // subcrate=0);
  // fatima_vme = fatima_vme_subev(type=10,subtype=1,procid=70,control=20,
                                // subcrate=0);
  // fatima_tamex = fatima_tamex_subev(type=10,subtype=1,procid=75,control=20,
                                    // subcrate=0);
  // aida = aida_subev(type=10,subtype=1,procid=90,control=37,subcrate=0);
  // frs_main = frs_main_subev(type=12,subtype=1,procid=10,control=20,
                            // subcrate=0);
  // frs_tpat = frs_tpat_subev(type=36,subtype=0xe10,procid=10,control=20,
                            // subcrate=0);
  // frs_frs = frs_frs_subev(type=12,subtype=1,procid=30,control=20,
                          // subcrate=0);
  // ignore_unknown_subevent;
{
}

/** END_PACKER ********************************************************/


/** BEGIN_REVOKE *******************************************************
 *
 * Event revoker for EVENT.
 *
 * Do not edit - automatically generated.
 */

// EVENT
int unpack_event::__revoke_subevent(subevent_header *__header)
  // germanium = germanium_subev(type=10,subtype=1,procid=60,control=20,
                              // subcrate=0);
  // fatima_vme = fatima_vme_subev(type=10,subtype=1,procid=70,control=20,
                                // subcrate=0);
  // fatima_tamex = fatima_tamex_subev(type=10,subtype=1,procid=75,control=20,
                                    // subcrate=0);
  // aida = aida_subev(type=10,subtype=1,procid=90,control=37,subcrate=0);
  // frs_main = frs_main_subev(type=12,subtype=1,procid=10,control=20,
                            // subcrate=0);
  // frs_tpat = frs_tpat_subev(type=36,subtype=0xe10,procid=10,control=20,
                            // subcrate=0);
  // frs_frs = frs_frs_subev(type=12,subtype=1,procid=30,control=20,
                          // subcrate=0);
  // ignore_unknown_subevent;
{
  int __match_no = 0;
  MATCH_SUBEVENT_DECL(451,__match_no,1,((VES10_1_type==10)&&(VES10_1_subtype==1)&&(VES10_1_control==20)&&(VES10_1_subcrate==0)&&(VES10_1_procid==60)),germanium);
  MATCH_SUBEVENT_DECL(453,__match_no,2,((VES10_1_type==10)&&(VES10_1_subtype==1)&&(VES10_1_control==20)&&(VES10_1_subcrate==0)&&(VES10_1_procid==70)),fatima_vme);
  MATCH_SUBEVENT_DECL(454,__match_no,3,((VES10_1_type==10)&&(VES10_1_subtype==1)&&(VES10_1_control==20)&&(VES10_1_subcrate==0)&&(VES10_1_procid==75)),fatima_tamex);
  MATCH_SUBEVENT_DECL(455,__match_no,4,((VES10_1_type==10)&&(VES10_1_subtype==1)&&(VES10_1_control==37)&&(VES10_1_subcrate==0)&&(VES10_1_procid==90)),aida);
  MATCH_SUBEVENT_DECL(459,__match_no,5,((VES10_1_type==12)&&(VES10_1_subtype==1)&&(VES10_1_control==20)&&(VES10_1_subcrate==0)&&(VES10_1_procid==10)),frs_main);
  MATCH_SUBEVENT_DECL(460,__match_no,6,((VES10_1_type==36)&&(VES10_1_subtype==0xe10)&&(VES10_1_control==20)&&(VES10_1_subcrate==0)&&(VES10_1_procid==10)),frs_tpat);
  MATCH_SUBEVENT_DECL(462,__match_no,7,((VES10_1_type==12)&&(VES10_1_subtype==1)&&(VES10_1_control==20)&&(VES10_1_subcrate==0)&&(VES10_1_procid==30)),frs_frs);
  if (!__match_no) return 0;
  switch (__match_no)
  {
    case 1:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(451,germanium_subev,germanium,0);
      REVOKE_SUBEVENT_DECL(451,0,germanium_subev,germanium);
      break;
    case 2:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(453,fatima_vme_subev,fatima_vme,1);
      REVOKE_SUBEVENT_DECL(453,0,fatima_vme_subev,fatima_vme);
      break;
    case 3:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(454,fatima_tamex_subev,fatima_tamex,2);
      REVOKE_SUBEVENT_DECL(454,0,fatima_tamex_subev,fatima_tamex);
      break;
    case 4:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(455,aida_subev,aida,3);
      REVOKE_SUBEVENT_DECL(455,0,aida_subev,aida);
      break;
    case 5:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(459,frs_main_subev,frs_main,4);
      REVOKE_SUBEVENT_DECL(459,0,frs_main_subev,frs_main);
      break;
    case 6:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(460,frs_tpat_subev,frs_tpat,5);
      REVOKE_SUBEVENT_DECL(460,0,frs_tpat_subev,frs_tpat);
      break;
    case 7:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(462,frs_frs_subev,frs_frs,6);
      REVOKE_SUBEVENT_DECL(462,0,frs_frs_subev,frs_frs);
      break;
  }
  return 0;
}

/** END_REVOKE ********************************************************/


/** BEGIN_SUBEVENT_NAMES ***********************************************
 *
 * Mappings of names for [incl|excl] name lookup.
 *
 * Do not edit - automatically generated.
 */

{ "germanium", "type=10:subtype=1:procid=60:control=20:subcrate=0" },
{ "fatima_vme", "type=10:subtype=1:procid=70:control=20:subcrate=0" },
{ "fatima_tamex", "type=10:subtype=1:procid=75:control=20:subcrate=0" },
{ "aida", "type=10:subtype=1:procid=90:control=37:subcrate=0" },
{ "frs_main", "type=12:subtype=1:procid=10:control=20:subcrate=0" },
{ "frs_tpat", "type=36:subtype=0xe10:procid=10:control=20:subcrate=0" },
{ "frs_frs", "type=12:subtype=1:procid=30:control=20:subcrate=0" },

/** END_SUBEVENT_NAMES ************************************************/

//
// Generating code for EVENT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for EVENT.
 *
 * Do not edit - automatically generated.
 */

// STICKY_EVENT
class unpack_sticky_event : public unpack_sticky_event_base
{
public:
public:
#ifndef __PSDC__
  void __clear_visited() { }
  bool ignore_unknown_subevent() { return false; }
#endif//!__PSDC__

public:
#ifndef __PSDC__
template<typename __data_src_t>
  int __unpack_subevent(subevent_header *__header,__data_src_t &__buffer);
  int __revoke_subevent(subevent_header *__header);
  // void __clean_event();

  STRUCT_FCNS_DECL(unpack_sticky_event);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for EVENT.
 *
 * Do not edit - automatically generated.
 */

// STICKY_EVENT
template<typename __data_src_t>
int unpack_sticky_event::__unpack_subevent(subevent_header *__header,__data_src_t &__buffer)
{
  int __match_no = 0;
  if (!__match_no) return 0;
  switch (__match_no)
  {
  }
  return 0;
}
FORCE_IMPL_DATA_SRC_FCN_HDR(int,unpack_sticky_event::__unpack_subevent);

/** END_UNPACKER ******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for EVENT.
 *
 * Do not edit - automatically generated.
 */

// STICKY_EVENT
{
}

/** END_PACKER ********************************************************/


/** BEGIN_REVOKE *******************************************************
 *
 * Event revoker for EVENT.
 *
 * Do not edit - automatically generated.
 */

// STICKY_EVENT
int unpack_sticky_event::__revoke_subevent(subevent_header *__header)
{
  int __match_no = 0;
  if (!__match_no) return 0;
  switch (__match_no)
  {
  }
  return 0;
}

/** END_REVOKE ********************************************************/


/** BEGIN_SUBEVENT_NAMES ***********************************************
 *
 * Mappings of names for [incl|excl] name lookup.
 *
 * Do not edit - automatically generated.
 */


/** END_SUBEVENT_NAMES ************************************************/


/** BEGIN_UNPACKER_DEFINES *********************************************
 *
 * Control
 *
 * Do not edit - automatically generated.
 */

#define STICKY_EVENT_IS_NONTRIVIAL  0


/** END_UNPACKER_DEFINES **********************************************/

/**********************************************************/
/**********************************************************
 * Generating event structure...
 */


/** BEGIN_EVENT_RAW_STRUCTURE ******************************************
 *
 * Event data structure.
 *
 * Do not edit - automatically generated.
 */

class raw_event : public raw_event_base
{
public:

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event);
#endif//!__PSDC__
} ;

/** END_EVENT_RAW_STRUCTURE *******************************************/


/** BEGIN_EVENT_CAL_STRUCTURE ******************************************
 *
 * Event data structure.
 *
 * Do not edit - automatically generated.
 */

class cal_event : public cal_event_base
{
public:

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(cal_event);
#endif//!__PSDC__
} ;

/** END_EVENT_CAL_STRUCTURE *******************************************/


/** BEGIN_EVENT_RAW_STRUCTURE ******************************************
 *
 * Event data structure.
 *
 * Do not edit - automatically generated.
 */

class raw_sticky : public raw_sticky_base
{
public:

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_sticky);
#endif//!__PSDC__
} ;

/** END_EVENT_RAW_STRUCTURE *******************************************/


/** BEGIN_EVENT_DATA_MAPPING *******************************************
 *
 * Event data mapping.
 *
 * Do not edit - automatically generated.
 */

// The order in this file does not matter.
// This information parsed once and not treated eventwise,
// it is used to initialize a structure.


/** END_EVENT_DATA_MAPPING ********************************************/


/** BEGIN_EVENT_DATA_MAPPING *******************************************
 *
 * Event data mapping.
 *
 * Do not edit - automatically generated.
 */

// The order in this file does not matter.
// This information parsed once and not treated eventwise,
// it is used to initialize a structure.


/** END_EVENT_DATA_MAPPING ********************************************/

/**********************************************************/

/** BEGIN_LOCATIONS ****************************************************
 *
 * File and line locations from the parsed specification files.
 *
 * Do not edit - automatically generated.
 */

// It's left to the compiler to only store one copy of each
// unique string.

location spec_locations[] =
{ 
  { 2, 1, "s452.spec" },
  { 3, 1, "<built-in>" },
  { 4, 1, "<command-line>" },
  { 5, 1, "/usr/include/stdc-predef.h" },
  { 6, 1, "<command-line>" },
  { 7, 1, "s452.spec" },
  { 10, 1, "aida_data.spec" },
  { 11, 29, "aida_data.spec" },
  { 30, 55, "aida_data.spec" },
  { 124, 4, "s452.spec" },
  { 127, 1, "fatima_data.spec" },
  { 184, 7, "s452.spec" },
  { 185, 1, "frs_data.spec" },
  { 262, 8, "s452.spec" },
  { 263, 1, "whiterabbit.spec" },
  { 352, 9, "s452.spec" },
};

/** END_LOCATIONS *****************************************************/


/** BEGIN_ACCOUNT_IDS **************************************************
 *
 * Structure and identifier for raw data items.
 *
 * Do not edit - automatically generated.
 */

account_id _account_ids[] =
{ 
  { 0, "AIDA_INFO", "wordA" },
  { 1, "AIDA_INFO", "wordB" },
  { 2, "AIDA_INFO", "wordA" },
  { 3, "AIDA_ADC", "wordA" },
  { 4, "AIDA_ADC", "wordB" },
  { 5, "AIDA_ADC", "wordA" },
  { 6, "DUMMY", "no" },
  { 7, "DUMMY", "no" },
  { 8, "FATIMA_SCALER", "header" },
  { 9, "FATIMA_SCALER", "ch_data" },
  { 10, "FATIMA_SCALER", "trailer" },
  { 11, "FATIMA_SCALER", "header" },
  { 12, "FRS_FRS", "no" },
  { 13, "FRS_FRS", "ch_data" },
  { 14, "FRS_FRS", "no" },
  { 15, "FRS_MAIN", "no" },
  { 16, "FRS_MAIN", "sc" },
  { 17, "FRS_MAIN", "ch_data" },
  { 18, "FRS_MAIN", "no" },
  { 19, "TIMESTAMP_WHITERABBIT", "header" },
  { 20, "TIMESTAMP_WHITERABBIT", "d1" },
  { 21, "TIMESTAMP_WHITERABBIT", "d2" },
  { 22, "TIMESTAMP_WHITERABBIT", "d3" },
  { 23, "TIMESTAMP_WHITERABBIT", "d4" },
  { 24, "TIMESTAMP_WHITERABBIT", "header" },
  { 25, "TIMESTAMP_WHITERABBIT_EXTENDED", "header" },
  { 26, "TIMESTAMP_WHITERABBIT_EXTENDED", "d1" },
  { 27, "TIMESTAMP_WHITERABBIT_EXTENDED", "d2" },
  { 28, "TIMESTAMP_WHITERABBIT_EXTENDED", "d3" },
  { 29, "TIMESTAMP_WHITERABBIT_EXTENDED", "d4" },
  { 30, "TIMESTAMP_WHITERABBIT_EXTENDED", "header" },
  { 31, "TRLOII_TPAT", "header" },
  { 32, "TRLOII_TPAT", "time_lo" },
  { 33, "TRLOII_TPAT", "time_hi" },
  { 34, "TRLOII_TPAT", "trigger" },
  { 35, "TRLOII_TPAT", "header" },
  { 36, "WR_MULTI", "hi" },
  { 37, "WR_MULTI", "lo" },
  { 38, "WR_MULTI", "hi" },
};

#define NUM_ACCOUNT_IDS  39

/** END_ACCOUNT_IDS ***************************************************/

