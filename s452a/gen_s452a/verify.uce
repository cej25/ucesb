
/** BEGIN_INPUT_DEFINITION *********************************************
 *
 * All specifications as seen by the parser.
 *
 * Do not edit - automatically generated.
 */

/**********************************************************
 * Dump of all structures:
 */

FEBEX_EVENT()
{
  MEMBER(DATA8 board_id);
  MEMBER(DATA32 event_trigger_time_hi);
  MEMBER(DATA32 event_trigger_time_lo);
  MEMBER(DATA16 hit_pattern);
  MEMBER(DATA32 num_channels_fired);
  MEMBER(DATA8 channel_id[16] ZERO_SUPPRESS);
  MEMBER(DATA16 channel_trigger_time_hi[16] ZERO_SUPPRESS);
  MEMBER(DATA32 channel_trigger_time_lo[16] ZERO_SUPPRESS);
  MEMBER(DATA8 pileup[16]);
  MEMBER(DATA8 overflow[16]);
  MEMBER(DATA8 channel_cfd[16] ZERO_SUPPRESS);
  MEMBER(DATA32 channel_energy[16] ZERO_SUPPRESS);
  UINT32 sumchannel NOENCODE
  {
     0_07: 52;
     8_11: trigger_type;
    12_15: sfpnr;
    16_23: board_id;
    24_31: 255;
    ENCODE(board_id,(value=board_id));
  }
  UINT32 channel_size NOENCODE
  {
     0_01: ignore;
     2_31: size;
    ENCODE(num_channels_fired,(value=((size / 4) - 1)));
  }
  UINT32 event_timestamp_hi NOENCODE
  {
     0_15: timestamp_hi;
    16_31: ignore;
    ENCODE(event_trigger_time_hi,(value=timestamp_hi));
  }
  UINT32 event_timestamp_lo NOENCODE
  {
     0_31: timestamp_lo;
    ENCODE(event_trigger_time_lo,(value=timestamp_lo));
  }
  UINT32 hp NOENCODE
  {
     0_15: hp;
    16_31: ignore;
    ENCODE(hit_pattern,(value=hp));
  }
  UINT32 deadbeef NOENCODE
  {
     0_31: 0xdeadbeef;
  }
  list(0<=index<((channel_size.size / 4) - 1))
  {
    UINT32 channelids NOENCODE
    {
       0_15: chan_ts_hi;
      16_23: channel_id_bits;
      24_31: 240;
      ENCODE(channel_id[index],(value=channel_id_bits));
      ENCODE(channel_trigger_time_hi[index],(value=chan_ts_hi));
    }
    UINT32 channel_ts NOENCODE
    {
       0_31: chan_ts_lo;
      ENCODE(channel_trigger_time_lo[index],(value=chan_ts_lo));
    }
    UINT32 chan_enrgy NOENCODE
    {
       0_23: chan_energy;
      24_29: TSF;
         30: pileup_flag;
         31: overflow_flag;
      ENCODE(channel_cfd[index],(value=TSF));
      ENCODE(channel_energy[index],(value=chan_energy));
      ENCODE(pileup[index],(value=pileup_flag));
      ENCODE(overflow[index],(value=overflow_flag));
    }
    UINT32 future_use NOENCODE
    {
       0_31: 0;
    }
  }
}

FEBEX_PADDING()
{
  UINT32 pads_data NOENCODE
  {
     0_11: counter;
    12_19: index;
    20_31: 0xadd;
  }
}

TIMESTAMP_WHITERABBIT(id)
{
  MEMBER(DATA12 subsystem_id);
  MEMBER(DATA16 t1);
  MEMBER(DATA16 t2);
  MEMBER(DATA16 t3);
  MEMBER(DATA16 t4);
  UINT32 header NOENCODE
  {
     0_11: id = MATCH(id);
    12_15: 0;
       16: error_bit;
    17_31: 0;
    ENCODE(subsystem_id,(value=id));
  }
  UINT32 d1 NOENCODE
  {
     0_15: t1;
    16_31: 0x3e1;
    ENCODE(t1,(value=t1));
  }
  UINT32 d2 NOENCODE
  {
     0_15: t2;
    16_31: 0x4e1;
    ENCODE(t2,(value=t2));
  }
  UINT32 d3 NOENCODE
  {
     0_15: t3;
    16_31: 0x5e1;
    ENCODE(t3,(value=t3));
  }
  UINT32 d4 NOENCODE
  {
     0_15: t4;
    16_31: 0x6e1;
    ENCODE(t4,(value=t4));
  }
}

TIMESTAMP_WHITERABBIT_EXTENDED(id)
{
  MEMBER(DATA16 subsystem_id);
  MEMBER(DATA16 t1);
  MEMBER(DATA16 t2);
  MEMBER(DATA16 t3);
  MEMBER(DATA16 t4);
  UINT32 header NOENCODE
  {
     0_12: id = MATCH(id);
    13_15: 0;
       16: error_bit;
    17_31: 0;
    ENCODE(subsystem_id,(value=id));
  }
  UINT32 d1 NOENCODE
  {
     0_15: t1;
    16_31: 0x3e1;
    ENCODE(t1,(value=t1));
  }
  UINT32 d2 NOENCODE
  {
     0_15: t2;
    16_31: 0x4e1;
    ENCODE(t2,(value=t2));
  }
  UINT32 d3 NOENCODE
  {
     0_15: t3;
    16_31: 0x5e1;
    ENCODE(t3,(value=t3));
  }
  UINT32 d4 NOENCODE
  {
     0_15: t4;
    16_31: 0x6e1;
    ENCODE(t4,(value=t4));
  }
}

WR_MULTI()
{
  MEMBER(DATA32 time_hi);
  MEMBER(DATA32 time_lo);
  UINT32 hi NOENCODE
  {
     0_31: time;
    ENCODE(time_hi,(value=time));
  }
  UINT32 lo NOENCODE
  {
     0_31: time;
    ENCODE(time_lo,(value=time));
  }
}

SUBEVENT(germanium_subev)
{
  ts = TIMESTAMP_WHITERABBIT(id=0x400);
  select several
  {
    padding = FEBEX_PADDING();
  }
  select several
  {
    data = FEBEX_EVENT();
  }
}

/**********************************************************
 * The event definition:
 */

EVENT
{
  germanium = germanium_subev(type=10,subtype=1,procid=60,control=20,
                              subcrate=0);
  ignore_unknown_subevent;
}

/**********************************************************
 * The sticky_event definition:
 */

/**********************************************************
 * Signal name mappings:
 */

SIGNAL(board_id,germanium.data.board_id,DATA8);
SIGNAL(channel_cfd1,germanium.data.channel_cfd[0],DATA8);
SIGNAL(channel_cfd10,germanium.data.channel_cfd[9],DATA8);
SIGNAL(channel_cfd11,germanium.data.channel_cfd[10],DATA8);
SIGNAL(channel_cfd12,germanium.data.channel_cfd[11],DATA8);
SIGNAL(channel_cfd13,germanium.data.channel_cfd[12],DATA8);
SIGNAL(channel_cfd14,germanium.data.channel_cfd[13],DATA8);
SIGNAL(channel_cfd15,germanium.data.channel_cfd[14],DATA8);
SIGNAL(channel_cfd16,germanium.data.channel_cfd[15],DATA8);
SIGNAL(channel_cfd2,germanium.data.channel_cfd[1],DATA8);
SIGNAL(channel_cfd3,germanium.data.channel_cfd[2],DATA8);
SIGNAL(channel_cfd4,germanium.data.channel_cfd[3],DATA8);
SIGNAL(channel_cfd5,germanium.data.channel_cfd[4],DATA8);
SIGNAL(channel_cfd6,germanium.data.channel_cfd[5],DATA8);
SIGNAL(channel_cfd7,germanium.data.channel_cfd[6],DATA8);
SIGNAL(channel_cfd8,germanium.data.channel_cfd[7],DATA8);
SIGNAL(channel_cfd9,germanium.data.channel_cfd[8],DATA8);
SIGNAL(channel_energy1,germanium.data.channel_energy[0],DATA32);
SIGNAL(channel_energy10,germanium.data.channel_energy[9],DATA32);
SIGNAL(channel_energy11,germanium.data.channel_energy[10],DATA32);
SIGNAL(channel_energy12,germanium.data.channel_energy[11],DATA32);
SIGNAL(channel_energy13,germanium.data.channel_energy[12],DATA32);
SIGNAL(channel_energy14,germanium.data.channel_energy[13],DATA32);
SIGNAL(channel_energy15,germanium.data.channel_energy[14],DATA32);
SIGNAL(channel_energy16,germanium.data.channel_energy[15],DATA32);
SIGNAL(channel_energy2,germanium.data.channel_energy[1],DATA32);
SIGNAL(channel_energy3,germanium.data.channel_energy[2],DATA32);
SIGNAL(channel_energy4,germanium.data.channel_energy[3],DATA32);
SIGNAL(channel_energy5,germanium.data.channel_energy[4],DATA32);
SIGNAL(channel_energy6,germanium.data.channel_energy[5],DATA32);
SIGNAL(channel_energy7,germanium.data.channel_energy[6],DATA32);
SIGNAL(channel_energy8,germanium.data.channel_energy[7],DATA32);
SIGNAL(channel_energy9,germanium.data.channel_energy[8],DATA32);
SIGNAL(channel_id1,germanium.data.channel_id[0],DATA8);
SIGNAL(channel_id10,germanium.data.channel_id[9],DATA8);
SIGNAL(channel_id11,germanium.data.channel_id[10],DATA8);
SIGNAL(channel_id12,germanium.data.channel_id[11],DATA8);
SIGNAL(channel_id13,germanium.data.channel_id[12],DATA8);
SIGNAL(channel_id14,germanium.data.channel_id[13],DATA8);
SIGNAL(channel_id15,germanium.data.channel_id[14],DATA8);
SIGNAL(channel_id16,germanium.data.channel_id[15],DATA8);
SIGNAL(channel_id2,germanium.data.channel_id[1],DATA8);
SIGNAL(channel_id3,germanium.data.channel_id[2],DATA8);
SIGNAL(channel_id4,germanium.data.channel_id[3],DATA8);
SIGNAL(channel_id5,germanium.data.channel_id[4],DATA8);
SIGNAL(channel_id6,germanium.data.channel_id[5],DATA8);
SIGNAL(channel_id7,germanium.data.channel_id[6],DATA8);
SIGNAL(channel_id8,germanium.data.channel_id[7],DATA8);
SIGNAL(channel_id9,germanium.data.channel_id[8],DATA8);
SIGNAL(channel_trigger_time_hi1,germanium.data.channel_trigger_time_hi[0],DATA16);
SIGNAL(channel_trigger_time_hi10,germanium.data.channel_trigger_time_hi[9],DATA16);
SIGNAL(channel_trigger_time_hi11,germanium.data.channel_trigger_time_hi[10],DATA16);
SIGNAL(channel_trigger_time_hi12,germanium.data.channel_trigger_time_hi[11],DATA16);
SIGNAL(channel_trigger_time_hi13,germanium.data.channel_trigger_time_hi[12],DATA16);
SIGNAL(channel_trigger_time_hi14,germanium.data.channel_trigger_time_hi[13],DATA16);
SIGNAL(channel_trigger_time_hi15,germanium.data.channel_trigger_time_hi[14],DATA16);
SIGNAL(channel_trigger_time_hi16,germanium.data.channel_trigger_time_hi[15],DATA16);
SIGNAL(channel_trigger_time_hi2,germanium.data.channel_trigger_time_hi[1],DATA16);
SIGNAL(channel_trigger_time_hi3,germanium.data.channel_trigger_time_hi[2],DATA16);
SIGNAL(channel_trigger_time_hi4,germanium.data.channel_trigger_time_hi[3],DATA16);
SIGNAL(channel_trigger_time_hi5,germanium.data.channel_trigger_time_hi[4],DATA16);
SIGNAL(channel_trigger_time_hi6,germanium.data.channel_trigger_time_hi[5],DATA16);
SIGNAL(channel_trigger_time_hi7,germanium.data.channel_trigger_time_hi[6],DATA16);
SIGNAL(channel_trigger_time_hi8,germanium.data.channel_trigger_time_hi[7],DATA16);
SIGNAL(channel_trigger_time_hi9,germanium.data.channel_trigger_time_hi[8],DATA16);
SIGNAL(channel_trigger_time_lo1,germanium.data.channel_trigger_time_lo[0],DATA32);
SIGNAL(channel_trigger_time_lo10,germanium.data.channel_trigger_time_lo[9],DATA32);
SIGNAL(channel_trigger_time_lo11,germanium.data.channel_trigger_time_lo[10],DATA32);
SIGNAL(channel_trigger_time_lo12,germanium.data.channel_trigger_time_lo[11],DATA32);
SIGNAL(channel_trigger_time_lo13,germanium.data.channel_trigger_time_lo[12],DATA32);
SIGNAL(channel_trigger_time_lo14,germanium.data.channel_trigger_time_lo[13],DATA32);
SIGNAL(channel_trigger_time_lo15,germanium.data.channel_trigger_time_lo[14],DATA32);
SIGNAL(channel_trigger_time_lo16,germanium.data.channel_trigger_time_lo[15],DATA32);
SIGNAL(channel_trigger_time_lo2,germanium.data.channel_trigger_time_lo[1],DATA32);
SIGNAL(channel_trigger_time_lo3,germanium.data.channel_trigger_time_lo[2],DATA32);
SIGNAL(channel_trigger_time_lo4,germanium.data.channel_trigger_time_lo[3],DATA32);
SIGNAL(channel_trigger_time_lo5,germanium.data.channel_trigger_time_lo[4],DATA32);
SIGNAL(channel_trigger_time_lo6,germanium.data.channel_trigger_time_lo[5],DATA32);
SIGNAL(channel_trigger_time_lo7,germanium.data.channel_trigger_time_lo[6],DATA32);
SIGNAL(channel_trigger_time_lo8,germanium.data.channel_trigger_time_lo[7],DATA32);
SIGNAL(channel_trigger_time_lo9,germanium.data.channel_trigger_time_lo[8],DATA32);
SIGNAL(event_trigger_time_hi,germanium.data.event_trigger_time_hi,DATA32);
SIGNAL(event_trigger_time_lo,germanium.data.event_trigger_time_lo,DATA32);
SIGNAL(hit_pattern,germanium.data.hit_pattern,DATA16);
SIGNAL(num_channels_fired,germanium.data.num_channels_fired,DATA32);
SIGNAL(overflow1,germanium.data.overflow[0],DATA8);
SIGNAL(overflow10,germanium.data.overflow[9],DATA8);
SIGNAL(overflow11,germanium.data.overflow[10],DATA8);
SIGNAL(overflow12,germanium.data.overflow[11],DATA8);
SIGNAL(overflow13,germanium.data.overflow[12],DATA8);
SIGNAL(overflow14,germanium.data.overflow[13],DATA8);
SIGNAL(overflow15,germanium.data.overflow[14],DATA8);
SIGNAL(overflow16,germanium.data.overflow[15],DATA8);
SIGNAL(overflow2,germanium.data.overflow[1],DATA8);
SIGNAL(overflow3,germanium.data.overflow[2],DATA8);
SIGNAL(overflow4,germanium.data.overflow[3],DATA8);
SIGNAL(overflow5,germanium.data.overflow[4],DATA8);
SIGNAL(overflow6,germanium.data.overflow[5],DATA8);
SIGNAL(overflow7,germanium.data.overflow[6],DATA8);
SIGNAL(overflow8,germanium.data.overflow[7],DATA8);
SIGNAL(overflow9,germanium.data.overflow[8],DATA8);
SIGNAL(pileup1,germanium.data.pileup[0],DATA8);
SIGNAL(pileup10,germanium.data.pileup[9],DATA8);
SIGNAL(pileup11,germanium.data.pileup[10],DATA8);
SIGNAL(pileup12,germanium.data.pileup[11],DATA8);
SIGNAL(pileup13,germanium.data.pileup[12],DATA8);
SIGNAL(pileup14,germanium.data.pileup[13],DATA8);
SIGNAL(pileup15,germanium.data.pileup[14],DATA8);
SIGNAL(pileup16,germanium.data.pileup[15],DATA8);
SIGNAL(pileup2,germanium.data.pileup[1],DATA8);
SIGNAL(pileup3,germanium.data.pileup[2],DATA8);
SIGNAL(pileup4,germanium.data.pileup[3],DATA8);
SIGNAL(pileup5,germanium.data.pileup[4],DATA8);
SIGNAL(pileup6,germanium.data.pileup[5],DATA8);
SIGNAL(pileup7,germanium.data.pileup[6],DATA8);
SIGNAL(pileup8,germanium.data.pileup[7],DATA8);
SIGNAL(pileup9,germanium.data.pileup[8],DATA8);
SIGNAL(wr_subsystem_id,germanium.ts.subsystem_id,DATA12);
SIGNAL(wr_t1,germanium.ts.t1,DATA16);
SIGNAL(wr_t2,germanium.ts.t2,DATA16);
SIGNAL(wr_t3,germanium.ts.t3,DATA16);
SIGNAL(wr_t4,germanium.ts.t4,DATA16);
/**********************************************************/

/** END_INPUT_DEFINITION **********************************************/

/**********************************************************
 * Generating unpacking code...
 */

//
// Generating code for: FEBEX_EVENT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for FEBEX_EVENT.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_EVENT()
#if !PACKER_CODE
# define DECLARED_UNPACK_FEBEX_EVENT
class FEBEX_EVENT
#else//PACKER_CODE
# define DECLARED_PACKER_FEBEX_EVENT
class PACKER_FEBEX_EVENT
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA8 board_id);
  DATA8 board_id;
  // MEMBER(DATA32 event_trigger_time_hi);
  DATA32 event_trigger_time_hi;
  // MEMBER(DATA32 event_trigger_time_lo);
  DATA32 event_trigger_time_lo;
  // MEMBER(DATA16 hit_pattern);
  DATA16 hit_pattern;
  // MEMBER(DATA32 num_channels_fired);
  DATA32 num_channels_fired;
  // MEMBER(DATA8 channel_id[16] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA8,DATA8,16> channel_id;
  // MEMBER(DATA16 channel_trigger_time_hi[16] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA16,DATA16,16> channel_trigger_time_hi;
  // MEMBER(DATA32 channel_trigger_time_lo[16] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,16> channel_trigger_time_lo;
  // MEMBER(DATA8 pileup[16]);
  raw_array<DATA8,DATA8,16> pileup;
  // MEMBER(DATA8 overflow[16]);
  raw_array<DATA8,DATA8,16> overflow;
  // MEMBER(DATA8 channel_cfd[16] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA8,DATA8,16> channel_cfd;
  // MEMBER(DATA32 channel_energy[16] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,16> channel_energy;
  // UINT32 sumchannel NOENCODE
  // {
    //  0_07: 52;
    //  8_11: trigger_type;
    // 12_15: sfpnr;
    // 16_23: board_id;
    // 24_31: 255;
    // ENCODE(board_id,(value=board_id));
  // }
  // UINT32 channel_size NOENCODE
  // {
    //  0_01: ignore;
    //  2_31: size;
    // ENCODE(num_channels_fired,(value=((size / 4) - 1)));
  // }
  // UINT32 event_timestamp_hi NOENCODE
  // {
    //  0_15: timestamp_hi;
    // 16_31: ignore;
    // ENCODE(event_trigger_time_hi,(value=timestamp_hi));
  // }
  // UINT32 event_timestamp_lo NOENCODE
  // {
    //  0_31: timestamp_lo;
    // ENCODE(event_trigger_time_lo,(value=timestamp_lo));
  // }
  // UINT32 hp NOENCODE
  // {
    //  0_15: hp;
    // 16_31: ignore;
    // ENCODE(hit_pattern,(value=hp));
  // }
  // UINT32 deadbeef NOENCODE
  // {
    //  0_31: 0xdeadbeef;
  // }
  // list(0<=index<((channel_size.size / 4) - 1))

    // UINT32 channelids NOENCODE
    // {
      //  0_15: chan_ts_hi;
      // 16_23: channel_id_bits;
      // 24_31: 240;
      // ENCODE(channel_id[index],(value=channel_id_bits));
      // ENCODE(channel_trigger_time_hi[index],(value=chan_ts_hi));
    // }
    // UINT32 channel_ts NOENCODE
    // {
      //  0_31: chan_ts_lo;
      // ENCODE(channel_trigger_time_lo[index],(value=chan_ts_lo));
    // }
    // UINT32 chan_enrgy NOENCODE
    // {
      //  0_23: chan_energy;
      // 24_29: TSF;
      //    30: pileup_flag;
      //    31: overflow_flag;
      // ENCODE(channel_cfd[index],(value=TSF));
      // ENCODE(channel_energy[index],(value=chan_energy));
      // ENCODE(pileup[index],(value=pileup_flag));
      // ENCODE(overflow[index],(value=overflow_flag));
    // }
    // UINT32 future_use NOENCODE
    // {
      //  0_31: 0;
    // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(FEBEX_EVENT);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for FEBEX_EVENT.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_EVENT()
template<typename __data_src_t>
void FEBEX_EVENT::__unpack(__data_src_t &__buffer)
{
  // MEMBER(DATA8 board_id);
  // MEMBER(DATA32 event_trigger_time_hi);
  // MEMBER(DATA32 event_trigger_time_lo);
  // MEMBER(DATA16 hit_pattern);
  // MEMBER(DATA32 num_channels_fired);
  // MEMBER(DATA8 channel_id[16] ZERO_SUPPRESS);
  // MEMBER(DATA16 channel_trigger_time_hi[16] ZERO_SUPPRESS);
  // MEMBER(DATA32 channel_trigger_time_lo[16] ZERO_SUPPRESS);
  // MEMBER(DATA8 pileup[16]);
  // MEMBER(DATA8 overflow[16]);
  // MEMBER(DATA8 channel_cfd[16] ZERO_SUPPRESS);
  // MEMBER(DATA32 channel_energy[16] ZERO_SUPPRESS);
  // UINT32 sumchannel NOENCODE
  // {
    //  0_07: 52;
    //  8_11: trigger_type;
    // 12_15: sfpnr;
    // 16_23: board_id;
    // 24_31: 255;
    // ENCODE(board_id,(value=board_id));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_7 : 8; // 0..7
      uint32 trigger_type : 4; // 8..11
      uint32 sfpnr : 4; // 12..15
      uint32 board_id : 8; // 16..23
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 board_id : 8; // 16..23
      uint32 sfpnr : 4; // 12..15
      uint32 trigger_type : 4; // 8..11
      uint32 unnamed_0_7 : 8; // 0..7
#endif
    };
    uint32  u32;
  } sumchannel;
  READ_FROM_BUFFER_FULL(30,uint32 ,sumchannel,sumchannel.u32,0);
  CHECK_BITS_EQUAL(24,sumchannel.unnamed_0_7,52);
  CHECK_BITS_EQUAL(28,sumchannel.unnamed_24_31,255);
  {
    board_id.value = sumchannel.board_id;
  }
  // UINT32 channel_size NOENCODE
  // {
    //  0_01: ignore;
    //  2_31: size;
    // ENCODE(num_channels_fired,(value=((size / 4) - 1)));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 ignore : 2; // 0..1
      uint32 size : 30; // 2..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 size : 30; // 2..31
      uint32 ignore : 2; // 0..1
#endif
    };
    uint32  u32;
  } channel_size;
  READ_FROM_BUFFER_FULL(36,uint32 ,channel_size,channel_size.u32,1);
  {
    num_channels_fired.value = ((channel_size.size / 4) - 1);
  }
  // UINT32 event_timestamp_hi NOENCODE
  // {
    //  0_15: timestamp_hi;
    // 16_31: ignore;
    // ENCODE(event_trigger_time_hi,(value=timestamp_hi));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 timestamp_hi : 16; // 0..15
      uint32 ignore : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 ignore : 16; // 16..31
      uint32 timestamp_hi : 16; // 0..15
#endif
    };
    uint32  u32;
  } event_timestamp_hi;
  READ_FROM_BUFFER_FULL(42,uint32 ,event_timestamp_hi,event_timestamp_hi.u32,2);
  {
    event_trigger_time_hi.value = event_timestamp_hi.timestamp_hi;
  }
  // UINT32 event_timestamp_lo NOENCODE
  // {
    //  0_31: timestamp_lo;
    // ENCODE(event_trigger_time_lo,(value=timestamp_lo));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 timestamp_lo : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 timestamp_lo : 32; // 0..31
#endif
    };
    uint32  u32;
  } event_timestamp_lo;
  READ_FROM_BUFFER_FULL(47,uint32 ,event_timestamp_lo,event_timestamp_lo.u32,3);
  {
    event_trigger_time_lo.value = event_timestamp_lo.timestamp_lo;
  }
  // UINT32 hp NOENCODE
  // {
    //  0_15: hp;
    // 16_31: ignore;
    // ENCODE(hit_pattern,(value=hp));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 hp : 16; // 0..15
      uint32 ignore : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 ignore : 16; // 16..31
      uint32 hp : 16; // 0..15
#endif
    };
    uint32  u32;
  } hp;
  READ_FROM_BUFFER_FULL(53,uint32 ,hp,hp.u32,4);
  {
    hit_pattern.value = hp.hp;
  }
  // UINT32 deadbeef NOENCODE
  // {
    //  0_31: 0xdeadbeef;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
    };
    uint32  u32;
  } deadbeef;
  READ_FROM_BUFFER_FULL(57,uint32 ,deadbeef,deadbeef.u32,5);
  CHECK_BITS_EQUAL(56,deadbeef.unnamed_0_31,0xdeadbeef);
  // list(0<=index<((channel_size.size / 4) - 1))

  for (uint32 index = 0; index < (uint32) (((channel_size.size / 4) - 1)); ++index)
  {
    // UINT32 channelids NOENCODE
    // {
      //  0_15: chan_ts_hi;
      // 16_23: channel_id_bits;
      // 24_31: 240;
      // ENCODE(channel_id[index],(value=channel_id_bits));
      // ENCODE(channel_trigger_time_hi[index],(value=chan_ts_hi));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 chan_ts_hi : 16; // 0..15
        uint32 channel_id_bits : 8; // 16..23
        uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 unnamed_24_31 : 8; // 24..31
        uint32 channel_id_bits : 8; // 16..23
        uint32 chan_ts_hi : 16; // 0..15
#endif
      };
      uint32  u32;
    } channelids;
    READ_FROM_BUFFER_FULL(67,uint32 ,channelids,channelids.u32,6);
    CHECK_BITS_EQUAL(64,channelids.unnamed_24_31,240);
    {
      {
        typedef __typeof__(*(&(channel_id))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = channel_id.insert_index(65,index);
        __item.value = channelids.channel_id_bits;
      }
      {
        typedef __typeof__(*(&(channel_trigger_time_hi))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = channel_trigger_time_hi.insert_index(66,index);
        __item.value = channelids.chan_ts_hi;
      }
    }
    // UINT32 channel_ts NOENCODE
    // {
      //  0_31: chan_ts_lo;
      // ENCODE(channel_trigger_time_lo[index],(value=chan_ts_lo));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 chan_ts_lo : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 chan_ts_lo : 32; // 0..31
#endif
      };
      uint32  u32;
    } channel_ts;
    READ_FROM_BUFFER_FULL(72,uint32 ,channel_ts,channel_ts.u32,7);
    {
      typedef __typeof__(*(&(channel_trigger_time_lo))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = channel_trigger_time_lo.insert_index(71,index);
      __item.value = channel_ts.chan_ts_lo;
    }
    // UINT32 chan_enrgy NOENCODE
    // {
      //  0_23: chan_energy;
      // 24_29: TSF;
      //    30: pileup_flag;
      //    31: overflow_flag;
      // ENCODE(channel_cfd[index],(value=TSF));
      // ENCODE(channel_energy[index],(value=chan_energy));
      // ENCODE(pileup[index],(value=pileup_flag));
      // ENCODE(overflow[index],(value=overflow_flag));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 chan_energy : 24; // 0..23
        uint32 TSF : 6; // 24..29
        uint32 pileup_flag : 1; // 30
        uint32 overflow_flag : 1; // 31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 overflow_flag : 1; // 31
        uint32 pileup_flag : 1; // 30
        uint32 TSF : 6; // 24..29
        uint32 chan_energy : 24; // 0..23
#endif
      };
      uint32  u32;
    } chan_enrgy;
    READ_FROM_BUFFER_FULL(83,uint32 ,chan_enrgy,chan_enrgy.u32,8);
    {
      {
        typedef __typeof__(*(&(channel_cfd))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = channel_cfd.insert_index(79,index);
        __item.value = chan_enrgy.TSF;
      }
      {
        typedef __typeof__(*(&(channel_energy))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = channel_energy.insert_index(80,index);
        __item.value = chan_enrgy.chan_energy;
      }
      {
        typedef __typeof__(*(&(pileup))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = pileup.insert_index(81,index);
        __item.value = chan_enrgy.pileup_flag;
      }
      {
        typedef __typeof__(*(&(overflow))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = overflow.insert_index(82,index);
        __item.value = chan_enrgy.overflow_flag;
      }
    }
    // UINT32 future_use NOENCODE
    // {
      //  0_31: 0;
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 unnamed_0_31 : 32; // 0..31
#endif
      };
      uint32  u32;
    } future_use;
    READ_FROM_BUFFER_FULL(87,uint32 ,future_use,future_use.u32,9);
    CHECK_BITS_EQUAL(86,future_use.unnamed_0_31,0);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,FEBEX_EVENT::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for FEBEX_EVENT.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_EVENT()
template<typename __data_src_t>
bool FEBEX_EVENT::__match(__data_src_t &__buffer)
{
  // MEMBER(DATA8 board_id);
  // MEMBER(DATA32 event_trigger_time_hi);
  // MEMBER(DATA32 event_trigger_time_lo);
  // MEMBER(DATA16 hit_pattern);
  // MEMBER(DATA32 num_channels_fired);
  // MEMBER(DATA8 channel_id[16] ZERO_SUPPRESS);
  // MEMBER(DATA16 channel_trigger_time_hi[16] ZERO_SUPPRESS);
  // MEMBER(DATA32 channel_trigger_time_lo[16] ZERO_SUPPRESS);
  // MEMBER(DATA8 pileup[16]);
  // MEMBER(DATA8 overflow[16]);
  // MEMBER(DATA8 channel_cfd[16] ZERO_SUPPRESS);
  // MEMBER(DATA32 channel_energy[16] ZERO_SUPPRESS);
  // UINT32 sumchannel NOENCODE
  // {
    //  0_07: 52;
    //  8_11: trigger_type;
    // 12_15: sfpnr;
    // 16_23: board_id;
    // 24_31: 255;
    // ENCODE(board_id,(value=board_id));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_7 : 8; // 0..7
      uint32 trigger_type : 4; // 8..11
      uint32 sfpnr : 4; // 12..15
      uint32 board_id : 8; // 16..23
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 board_id : 8; // 16..23
      uint32 sfpnr : 4; // 12..15
      uint32 trigger_type : 4; // 8..11
      uint32 unnamed_0_7 : 8; // 0..7
#endif
    };
    uint32  u32;
  } sumchannel;
  MATCH_READ_FROM_BUFFER_FULL(30,uint32 ,sumchannel,sumchannel.u32,10);
  MATCH_BITS_EQUAL(24,sumchannel.unnamed_0_7,52);
  MATCH_BITS_EQUAL(28,sumchannel.unnamed_24_31,255);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,FEBEX_EVENT::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for FEBEX_EVENT.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_EVENT()
template<typename __data_dest_t>
void PACKER_FEBEX_EVENT::__packer(__data_dest_t &__buffer)
{
  // MEMBER(DATA8 board_id);
  // MEMBER(DATA32 event_trigger_time_hi);
  // MEMBER(DATA32 event_trigger_time_lo);
  // MEMBER(DATA16 hit_pattern);
  // MEMBER(DATA32 num_channels_fired);
  // MEMBER(DATA8 channel_id[16] ZERO_SUPPRESS);
  // MEMBER(DATA16 channel_trigger_time_hi[16] ZERO_SUPPRESS);
  // MEMBER(DATA32 channel_trigger_time_lo[16] ZERO_SUPPRESS);
  // MEMBER(DATA8 pileup[16]);
  // MEMBER(DATA8 overflow[16]);
  // MEMBER(DATA8 channel_cfd[16] ZERO_SUPPRESS);
  // MEMBER(DATA32 channel_energy[16] ZERO_SUPPRESS);
  // UINT32 sumchannel NOENCODE
  // {
    //  0_07: 52;
    //  8_11: trigger_type;
    // 12_15: sfpnr;
    // 16_23: board_id;
    // 24_31: 255;
    // ENCODE(board_id,(value=board_id));
  // }
  // UINT32 channel_size NOENCODE
  // {
    //  0_01: ignore;
    //  2_31: size;
    // ENCODE(num_channels_fired,(value=((size / 4) - 1)));
  // }
  // UINT32 event_timestamp_hi NOENCODE
  // {
    //  0_15: timestamp_hi;
    // 16_31: ignore;
    // ENCODE(event_trigger_time_hi,(value=timestamp_hi));
  // }
  // UINT32 event_timestamp_lo NOENCODE
  // {
    //  0_31: timestamp_lo;
    // ENCODE(event_trigger_time_lo,(value=timestamp_lo));
  // }
  // UINT32 hp NOENCODE
  // {
    //  0_15: hp;
    // 16_31: ignore;
    // ENCODE(hit_pattern,(value=hp));
  // }
  // UINT32 deadbeef NOENCODE
  // {
    //  0_31: 0xdeadbeef;
  // }
  // list(0<=index<((channel_size.size / 4) - 1))

  {
    // UINT32 channelids NOENCODE
    // {
      //  0_15: chan_ts_hi;
      // 16_23: channel_id_bits;
      // 24_31: 240;
      // ENCODE(channel_id[index],(value=channel_id_bits));
      // ENCODE(channel_trigger_time_hi[index],(value=chan_ts_hi));
    // }
    // UINT32 channel_ts NOENCODE
    // {
      //  0_31: chan_ts_lo;
      // ENCODE(channel_trigger_time_lo[index],(value=chan_ts_lo));
    // }
    // UINT32 chan_enrgy NOENCODE
    // {
      //  0_23: chan_energy;
      // 24_29: TSF;
      //    30: pileup_flag;
      //    31: overflow_flag;
      // ENCODE(channel_cfd[index],(value=TSF));
      // ENCODE(channel_energy[index],(value=chan_energy));
      // ENCODE(pileup[index],(value=pileup_flag));
      // ENCODE(overflow[index],(value=overflow_flag));
    // }
    // UINT32 future_use NOENCODE
    // {
      //  0_31: 0;
    // }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,FEBEX_EVENT::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: FEBEX_PADDING
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for FEBEX_PADDING.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_PADDING()
#if !PACKER_CODE
# define DECLARED_UNPACK_FEBEX_PADDING
class FEBEX_PADDING
#else//PACKER_CODE
# define DECLARED_PACKER_FEBEX_PADDING
class PACKER_FEBEX_PADDING
#endif//PACKER_CODE

{
public:
  // UINT32 pads_data NOENCODE
  // {
    //  0_11: counter;
    // 12_19: index;
    // 20_31: 0xadd;
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(FEBEX_PADDING);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for FEBEX_PADDING.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_PADDING()
template<typename __data_src_t>
void FEBEX_PADDING::__unpack(__data_src_t &__buffer)
{
  // UINT32 pads_data NOENCODE
  // {
    //  0_11: counter;
    // 12_19: index;
    // 20_31: 0xadd;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 counter : 12; // 0..11
      uint32 index : 8; // 12..19
      uint32 unnamed_20_31 : 12; // 20..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_20_31 : 12; // 20..31
      uint32 index : 8; // 12..19
      uint32 counter : 12; // 0..11
#endif
    };
    uint32  u32;
  } pads_data;
  READ_FROM_BUFFER_FULL(98,uint32 ,pads_data,pads_data.u32,11);
  CHECK_BITS_EQUAL(97,pads_data.unnamed_20_31,0xadd);
}
FORCE_IMPL_DATA_SRC_FCN(void,FEBEX_PADDING::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for FEBEX_PADDING.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_PADDING()
template<typename __data_src_t>
bool FEBEX_PADDING::__match(__data_src_t &__buffer)
{
  // UINT32 pads_data NOENCODE
  // {
    //  0_11: counter;
    // 12_19: index;
    // 20_31: 0xadd;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 counter : 12; // 0..11
      uint32 index : 8; // 12..19
      uint32 unnamed_20_31 : 12; // 20..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_20_31 : 12; // 20..31
      uint32 index : 8; // 12..19
      uint32 counter : 12; // 0..11
#endif
    };
    uint32  u32;
  } pads_data;
  MATCH_READ_FROM_BUFFER_FULL(98,uint32 ,pads_data,pads_data.u32,12);
  MATCH_BITS_EQUAL(97,pads_data.unnamed_20_31,0xadd);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,FEBEX_PADDING::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for FEBEX_PADDING.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_PADDING()
template<typename __data_dest_t>
void PACKER_FEBEX_PADDING::__packer(__data_dest_t &__buffer)
{
  // UINT32 pads_data NOENCODE
  // {
    //  0_11: counter;
    // 12_19: index;
    // 20_31: 0xadd;
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,FEBEX_PADDING::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: TIMESTAMP_WHITERABBIT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TIMESTAMP_WHITERABBIT.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT(id)
#if !PACKER_CODE
# define DECLARED_UNPACK_TIMESTAMP_WHITERABBIT
class TIMESTAMP_WHITERABBIT
#else//PACKER_CODE
# define DECLARED_PACKER_TIMESTAMP_WHITERABBIT
class PACKER_TIMESTAMP_WHITERABBIT
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA12 subsystem_id);
  DATA12 subsystem_id;
  // MEMBER(DATA16 t1);
  DATA16 t1;
  // MEMBER(DATA16 t2);
  DATA16 t2;
  // MEMBER(DATA16 t3);
  DATA16 t3;
  // MEMBER(DATA16 t4);
  DATA16 t4;
  // UINT32 header NOENCODE
  // {
    //  0_11: id = MATCH(id);
    // 12_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  // UINT32 d1 NOENCODE
  // {
    //  0_15: t1;
    // 16_31: 0x3e1;
    // ENCODE(t1,(value=t1));
  // }
  // UINT32 d2 NOENCODE
  // {
    //  0_15: t2;
    // 16_31: 0x4e1;
    // ENCODE(t2,(value=t2));
  // }
  // UINT32 d3 NOENCODE
  // {
    //  0_15: t3;
    // 16_31: 0x5e1;
    // ENCODE(t3,(value=t3));
  // }
  // UINT32 d4 NOENCODE
  // {
    //  0_15: t4;
    // 16_31: 0x6e1;
    // ENCODE(t4,(value=t4));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 id);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 id);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TIMESTAMP_WHITERABBIT);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TIMESTAMP_WHITERABBIT.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT(id)
template<typename __data_src_t>
void TIMESTAMP_WHITERABBIT::__unpack(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA12 subsystem_id);
  // MEMBER(DATA16 t1);
  // MEMBER(DATA16 t2);
  // MEMBER(DATA16 t3);
  // MEMBER(DATA16 t4);
  // UINT32 header NOENCODE
  // {
    //  0_11: id = MATCH(id);
    // 12_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 id : 12; // 0..11
      uint32 unnamed_12_15 : 4; // 12..15
      uint32 error_bit : 1; // 16
      uint32 unnamed_17_31 : 15; // 17..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_17_31 : 15; // 17..31
      uint32 error_bit : 1; // 16
      uint32 unnamed_12_15 : 4; // 12..15
      uint32 id : 12; // 0..11
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(115,uint32 ,header,header.u32,13);
  CHECK_BITS_EQUAL(110,header.id,id);
  CHECK_BITS_EQUAL(111,header.unnamed_12_15,0);
  CHECK_BITS_EQUAL(113,header.unnamed_17_31,0);
  {
    subsystem_id.value = header.id;
  }
  // UINT32 d1 NOENCODE
  // {
    //  0_15: t1;
    // 16_31: 0x3e1;
    // ENCODE(t1,(value=t1));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t1 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t1 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d1;
  READ_FROM_BUFFER_FULL(121,uint32 ,d1,d1.u32,14);
  CHECK_BITS_EQUAL(119,d1.unnamed_16_31,0x3e1);
  {
    t1.value = d1.t1;
  }
  // UINT32 d2 NOENCODE
  // {
    //  0_15: t2;
    // 16_31: 0x4e1;
    // ENCODE(t2,(value=t2));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t2 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t2 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d2;
  READ_FROM_BUFFER_FULL(127,uint32 ,d2,d2.u32,15);
  CHECK_BITS_EQUAL(125,d2.unnamed_16_31,0x4e1);
  {
    t2.value = d2.t2;
  }
  // UINT32 d3 NOENCODE
  // {
    //  0_15: t3;
    // 16_31: 0x5e1;
    // ENCODE(t3,(value=t3));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t3 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t3 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d3;
  READ_FROM_BUFFER_FULL(133,uint32 ,d3,d3.u32,16);
  CHECK_BITS_EQUAL(131,d3.unnamed_16_31,0x5e1);
  {
    t3.value = d3.t3;
  }
  // UINT32 d4 NOENCODE
  // {
    //  0_15: t4;
    // 16_31: 0x6e1;
    // ENCODE(t4,(value=t4));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t4 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t4 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d4;
  READ_FROM_BUFFER_FULL(139,uint32 ,d4,d4.u32,17);
  CHECK_BITS_EQUAL(137,d4.unnamed_16_31,0x6e1);
  {
    t4.value = d4.t4;
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TIMESTAMP_WHITERABBIT::__unpack,uint32 id);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TIMESTAMP_WHITERABBIT.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT(id)
template<typename __data_src_t>
bool TIMESTAMP_WHITERABBIT::__match(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA12 subsystem_id);
  // MEMBER(DATA16 t1);
  // MEMBER(DATA16 t2);
  // MEMBER(DATA16 t3);
  // MEMBER(DATA16 t4);
  // UINT32 header NOENCODE
  // {
    //  0_11: id = MATCH(id);
    // 12_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 id : 12; // 0..11
      uint32 unnamed_12_15 : 4; // 12..15
      uint32 error_bit : 1; // 16
      uint32 unnamed_17_31 : 15; // 17..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_17_31 : 15; // 17..31
      uint32 error_bit : 1; // 16
      uint32 unnamed_12_15 : 4; // 12..15
      uint32 id : 12; // 0..11
#endif
    };
    uint32  u32;
  } header;
  MATCH_READ_FROM_BUFFER_FULL(115,uint32 ,header,header.u32,18);
  MATCH_BITS_EQUAL(110,header.id,id);
  MATCH_BITS_EQUAL(111,header.unnamed_12_15,0);
  MATCH_BITS_EQUAL(113,header.unnamed_17_31,0);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,TIMESTAMP_WHITERABBIT::__match,uint32 id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TIMESTAMP_WHITERABBIT.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT(id)
template<typename __data_dest_t>
void PACKER_TIMESTAMP_WHITERABBIT::__packer(__data_dest_t &__buffer,uint32 id)
{
  // MEMBER(DATA12 subsystem_id);
  // MEMBER(DATA16 t1);
  // MEMBER(DATA16 t2);
  // MEMBER(DATA16 t3);
  // MEMBER(DATA16 t4);
  // UINT32 header NOENCODE
  // {
    //  0_11: id = MATCH(id);
    // 12_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  // UINT32 d1 NOENCODE
  // {
    //  0_15: t1;
    // 16_31: 0x3e1;
    // ENCODE(t1,(value=t1));
  // }
  // UINT32 d2 NOENCODE
  // {
    //  0_15: t2;
    // 16_31: 0x4e1;
    // ENCODE(t2,(value=t2));
  // }
  // UINT32 d3 NOENCODE
  // {
    //  0_15: t3;
    // 16_31: 0x5e1;
    // ENCODE(t3,(value=t3));
  // }
  // UINT32 d4 NOENCODE
  // {
    //  0_15: t4;
    // 16_31: 0x6e1;
    // ENCODE(t4,(value=t4));
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TIMESTAMP_WHITERABBIT::__packer,uint32 id);

/** END_PACKER ********************************************************/

//
// Generating code for: TIMESTAMP_WHITERABBIT_EXTENDED
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TIMESTAMP_WHITERABBIT_EXTENDED.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT_EXTENDED(id)
#if !PACKER_CODE
# define DECLARED_UNPACK_TIMESTAMP_WHITERABBIT_EXTENDED
class TIMESTAMP_WHITERABBIT_EXTENDED
#else//PACKER_CODE
# define DECLARED_PACKER_TIMESTAMP_WHITERABBIT_EXTENDED
class PACKER_TIMESTAMP_WHITERABBIT_EXTENDED
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA16 subsystem_id);
  DATA16 subsystem_id;
  // MEMBER(DATA16 t1);
  DATA16 t1;
  // MEMBER(DATA16 t2);
  DATA16 t2;
  // MEMBER(DATA16 t3);
  DATA16 t3;
  // MEMBER(DATA16 t4);
  DATA16 t4;
  // UINT32 header NOENCODE
  // {
    //  0_12: id = MATCH(id);
    // 13_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  // UINT32 d1 NOENCODE
  // {
    //  0_15: t1;
    // 16_31: 0x3e1;
    // ENCODE(t1,(value=t1));
  // }
  // UINT32 d2 NOENCODE
  // {
    //  0_15: t2;
    // 16_31: 0x4e1;
    // ENCODE(t2,(value=t2));
  // }
  // UINT32 d3 NOENCODE
  // {
    //  0_15: t3;
    // 16_31: 0x5e1;
    // ENCODE(t3,(value=t3));
  // }
  // UINT32 d4 NOENCODE
  // {
    //  0_15: t4;
    // 16_31: 0x6e1;
    // ENCODE(t4,(value=t4));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 id);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 id);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TIMESTAMP_WHITERABBIT_EXTENDED);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TIMESTAMP_WHITERABBIT_EXTENDED.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT_EXTENDED(id)
template<typename __data_src_t>
void TIMESTAMP_WHITERABBIT_EXTENDED::__unpack(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA16 subsystem_id);
  // MEMBER(DATA16 t1);
  // MEMBER(DATA16 t2);
  // MEMBER(DATA16 t3);
  // MEMBER(DATA16 t4);
  // UINT32 header NOENCODE
  // {
    //  0_12: id = MATCH(id);
    // 13_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 id : 13; // 0..12
      uint32 unnamed_13_15 : 3; // 13..15
      uint32 error_bit : 1; // 16
      uint32 unnamed_17_31 : 15; // 17..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_17_31 : 15; // 17..31
      uint32 error_bit : 1; // 16
      uint32 unnamed_13_15 : 3; // 13..15
      uint32 id : 13; // 0..12
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(156,uint32 ,header,header.u32,19);
  CHECK_BITS_EQUAL(151,header.id,id);
  CHECK_BITS_EQUAL(152,header.unnamed_13_15,0);
  CHECK_BITS_EQUAL(154,header.unnamed_17_31,0);
  {
    subsystem_id.value = header.id;
  }
  // UINT32 d1 NOENCODE
  // {
    //  0_15: t1;
    // 16_31: 0x3e1;
    // ENCODE(t1,(value=t1));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t1 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t1 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d1;
  READ_FROM_BUFFER_FULL(162,uint32 ,d1,d1.u32,20);
  CHECK_BITS_EQUAL(160,d1.unnamed_16_31,0x3e1);
  {
    t1.value = d1.t1;
  }
  // UINT32 d2 NOENCODE
  // {
    //  0_15: t2;
    // 16_31: 0x4e1;
    // ENCODE(t2,(value=t2));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t2 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t2 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d2;
  READ_FROM_BUFFER_FULL(168,uint32 ,d2,d2.u32,21);
  CHECK_BITS_EQUAL(166,d2.unnamed_16_31,0x4e1);
  {
    t2.value = d2.t2;
  }
  // UINT32 d3 NOENCODE
  // {
    //  0_15: t3;
    // 16_31: 0x5e1;
    // ENCODE(t3,(value=t3));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t3 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t3 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d3;
  READ_FROM_BUFFER_FULL(174,uint32 ,d3,d3.u32,22);
  CHECK_BITS_EQUAL(172,d3.unnamed_16_31,0x5e1);
  {
    t3.value = d3.t3;
  }
  // UINT32 d4 NOENCODE
  // {
    //  0_15: t4;
    // 16_31: 0x6e1;
    // ENCODE(t4,(value=t4));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t4 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t4 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d4;
  READ_FROM_BUFFER_FULL(180,uint32 ,d4,d4.u32,23);
  CHECK_BITS_EQUAL(178,d4.unnamed_16_31,0x6e1);
  {
    t4.value = d4.t4;
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TIMESTAMP_WHITERABBIT_EXTENDED::__unpack,uint32 id);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TIMESTAMP_WHITERABBIT_EXTENDED.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT_EXTENDED(id)
template<typename __data_src_t>
bool TIMESTAMP_WHITERABBIT_EXTENDED::__match(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA16 subsystem_id);
  // MEMBER(DATA16 t1);
  // MEMBER(DATA16 t2);
  // MEMBER(DATA16 t3);
  // MEMBER(DATA16 t4);
  // UINT32 header NOENCODE
  // {
    //  0_12: id = MATCH(id);
    // 13_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 id : 13; // 0..12
      uint32 unnamed_13_15 : 3; // 13..15
      uint32 error_bit : 1; // 16
      uint32 unnamed_17_31 : 15; // 17..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_17_31 : 15; // 17..31
      uint32 error_bit : 1; // 16
      uint32 unnamed_13_15 : 3; // 13..15
      uint32 id : 13; // 0..12
#endif
    };
    uint32  u32;
  } header;
  MATCH_READ_FROM_BUFFER_FULL(156,uint32 ,header,header.u32,24);
  MATCH_BITS_EQUAL(151,header.id,id);
  MATCH_BITS_EQUAL(152,header.unnamed_13_15,0);
  MATCH_BITS_EQUAL(154,header.unnamed_17_31,0);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,TIMESTAMP_WHITERABBIT_EXTENDED::__match,uint32 id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TIMESTAMP_WHITERABBIT_EXTENDED.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT_EXTENDED(id)
template<typename __data_dest_t>
void PACKER_TIMESTAMP_WHITERABBIT_EXTENDED::__packer(__data_dest_t &__buffer,uint32 id)
{
  // MEMBER(DATA16 subsystem_id);
  // MEMBER(DATA16 t1);
  // MEMBER(DATA16 t2);
  // MEMBER(DATA16 t3);
  // MEMBER(DATA16 t4);
  // UINT32 header NOENCODE
  // {
    //  0_12: id = MATCH(id);
    // 13_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  // UINT32 d1 NOENCODE
  // {
    //  0_15: t1;
    // 16_31: 0x3e1;
    // ENCODE(t1,(value=t1));
  // }
  // UINT32 d2 NOENCODE
  // {
    //  0_15: t2;
    // 16_31: 0x4e1;
    // ENCODE(t2,(value=t2));
  // }
  // UINT32 d3 NOENCODE
  // {
    //  0_15: t3;
    // 16_31: 0x5e1;
    // ENCODE(t3,(value=t3));
  // }
  // UINT32 d4 NOENCODE
  // {
    //  0_15: t4;
    // 16_31: 0x6e1;
    // ENCODE(t4,(value=t4));
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TIMESTAMP_WHITERABBIT_EXTENDED::__packer,uint32 id);

/** END_PACKER ********************************************************/

//
// Generating code for: WR_MULTI
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for WR_MULTI.
 *
 * Do not edit - automatically generated.
 */

// WR_MULTI()
#if !PACKER_CODE
# define DECLARED_UNPACK_WR_MULTI
class WR_MULTI
#else//PACKER_CODE
# define DECLARED_PACKER_WR_MULTI
class PACKER_WR_MULTI
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA32 time_hi);
  DATA32 time_hi;
  // MEMBER(DATA32 time_lo);
  DATA32 time_lo;
  // UINT32 hi NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_hi,(value=time));
  // }
  // UINT32 lo NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_lo,(value=time));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(WR_MULTI);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for WR_MULTI.
 *
 * Do not edit - automatically generated.
 */

// WR_MULTI()
template<typename __data_src_t>
void WR_MULTI::__unpack(__data_src_t &__buffer)
{
  // MEMBER(DATA32 time_hi);
  // MEMBER(DATA32 time_lo);
  // UINT32 hi NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_hi,(value=time));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 time : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 time : 32; // 0..31
#endif
    };
    uint32  u32;
  } hi;
  READ_FROM_BUFFER_FULL(191,uint32 ,hi,hi.u32,25);
  {
    time_hi.value = hi.time;
  }
  // UINT32 lo NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_lo,(value=time));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 time : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 time : 32; // 0..31
#endif
    };
    uint32  u32;
  } lo;
  READ_FROM_BUFFER_FULL(196,uint32 ,lo,lo.u32,26);
  {
    time_lo.value = lo.time;
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,WR_MULTI::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for WR_MULTI.
 *
 * Do not edit - automatically generated.
 */

// WR_MULTI()
template<typename __data_src_t>
bool WR_MULTI::__match(__data_src_t &__buffer)
{
  // MEMBER(DATA32 time_hi);
  // MEMBER(DATA32 time_lo);
  // UINT32 hi NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_hi,(value=time));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 time : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 time : 32; // 0..31
#endif
    };
    uint32  u32;
  } hi;
  MATCH_READ_FROM_BUFFER_FULL(191,uint32 ,hi,hi.u32,27);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,WR_MULTI::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for WR_MULTI.
 *
 * Do not edit - automatically generated.
 */

// WR_MULTI()
template<typename __data_dest_t>
void PACKER_WR_MULTI::__packer(__data_dest_t &__buffer)
{
  // MEMBER(DATA32 time_hi);
  // MEMBER(DATA32 time_lo);
  // UINT32 hi NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_hi,(value=time));
  // }
  // UINT32 lo NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_lo,(value=time));
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,WR_MULTI::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: germanium_subev
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for germanium_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(germanium_subev)
#if !PACKER_CODE
# define DECLARED_UNPACK_germanium_subev
class germanium_subev
#else//PACKER_CODE
# define DECLARED_PACKER_germanium_subev
class PACKER_germanium_subev
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // ts = TIMESTAMP_WHITERABBIT(id=0x400);
  // select several

    // padding = FEBEX_PADDING();
  SINGLE(FEBEX_PADDING,padding);
  // select several

    // data = FEBEX_EVENT();
  SINGLE(FEBEX_EVENT,data);
  SINGLE(TIMESTAMP_WHITERABBIT,ts);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(germanium_subev);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for germanium_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(germanium_subev)
template<typename __data_src_t>
void germanium_subev::__unpack(__data_src_t &__buffer)
{
  // ts = TIMESTAMP_WHITERABBIT(id=0x400);
  UNPACK_DECL(201,TIMESTAMP_WHITERABBIT,ts,/*id*/0x400);
  // select several

    // padding = FEBEX_PADDING();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: FEBEX_PADDING padding: (s32) => (0xfff00000,0xadd00000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(205,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(204,spurious_match_abort_loop_0,FEBEX_PADDING);
        UNPACK_DECL(204,FEBEX_PADDING,padding);
        break;
    }
  }
  spurious_match_abort_loop_0:;
  // select several

    // data = FEBEX_EVENT();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: FEBEX_EVENT data: (s32) => (0xff0000ff,0xff000034)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(209,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 1
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(208,FEBEX_EVENT,data);
        break;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,germanium_subev::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for germanium_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(germanium_subev)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for germanium_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(germanium_subev)
template<typename __data_dest_t>
void PACKER_germanium_subev::__packer(__data_dest_t &__buffer)
{
  // ts = TIMESTAMP_WHITERABBIT(id=0x400);
  PACK_DECL(201,TIMESTAMP_WHITERABBIT,ts,/*id*/0x400);
  // select several

    // padding = FEBEX_PADDING();
  {
    PACK_DECL(204,FEBEX_PADDING,padding);
  }
  // select several

    // data = FEBEX_EVENT();
  {
    PACK_DECL(208,FEBEX_EVENT,data);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,germanium_subev::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for EVENT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for EVENT.
 *
 * Do not edit - automatically generated.
 */

// EVENT
class unpack_event : public unpack_event_base
{
public:
  // germanium = germanium_subev(type=10,subtype=1,procid=60,control=20,
                              // subcrate=0);
  // ignore_unknown_subevent;
SINGLE(germanium_subev,germanium);
public:
#ifndef __PSDC__
  bitsone<2> __visited;
  void __clear_visited() { __visited.clear(); }
  bool ignore_unknown_subevent() { return true; }
#endif//!__PSDC__

public:
#ifndef __PSDC__
template<typename __data_src_t>
  int __unpack_subevent(subevent_header *__header,__data_src_t &__buffer);
  int __revoke_subevent(subevent_header *__header);
  // void __clean_event();

  STRUCT_FCNS_DECL(unpack_event);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for EVENT.
 *
 * Do not edit - automatically generated.
 */

// EVENT
template<typename __data_src_t>
int unpack_event::__unpack_subevent(subevent_header *__header,__data_src_t &__buffer)
  // germanium = germanium_subev(type=10,subtype=1,procid=60,control=20,
                              // subcrate=0);
  // ignore_unknown_subevent;
{
  int __match_no = 0;
  MATCH_SUBEVENT_DECL(219,__match_no,1,((VES10_1_type==10)&&(VES10_1_subtype==1)&&(VES10_1_control==20)&&(VES10_1_subcrate==0)&&(VES10_1_procid==60)),germanium);
  if (!__match_no) return 0;
  switch (__match_no)
  {
    case 1:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(219,germanium_subev,germanium,0);
      UNPACK_SUBEVENT_DECL(219,0,germanium_subev,germanium);
      break;
  }
  return 0;
}
FORCE_IMPL_DATA_SRC_FCN_HDR(int,unpack_event::__unpack_subevent);

/** END_UNPACKER ******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for EVENT.
 *
 * Do not edit - automatically generated.
 */

// EVENT
  // germanium = germanium_subev(type=10,subtype=1,procid=60,control=20,
                              // subcrate=0);
  // ignore_unknown_subevent;
{
}

/** END_PACKER ********************************************************/


/** BEGIN_REVOKE *******************************************************
 *
 * Event revoker for EVENT.
 *
 * Do not edit - automatically generated.
 */

// EVENT
int unpack_event::__revoke_subevent(subevent_header *__header)
  // germanium = germanium_subev(type=10,subtype=1,procid=60,control=20,
                              // subcrate=0);
  // ignore_unknown_subevent;
{
  int __match_no = 0;
  MATCH_SUBEVENT_DECL(219,__match_no,1,((VES10_1_type==10)&&(VES10_1_subtype==1)&&(VES10_1_control==20)&&(VES10_1_subcrate==0)&&(VES10_1_procid==60)),germanium);
  if (!__match_no) return 0;
  switch (__match_no)
  {
    case 1:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(219,germanium_subev,germanium,0);
      REVOKE_SUBEVENT_DECL(219,0,germanium_subev,germanium);
      break;
  }
  return 0;
}

/** END_REVOKE ********************************************************/


/** BEGIN_SUBEVENT_NAMES ***********************************************
 *
 * Mappings of names for [incl|excl] name lookup.
 *
 * Do not edit - automatically generated.
 */

{ "germanium", "type=10:subtype=1:procid=60:control=20:subcrate=0" },

/** END_SUBEVENT_NAMES ************************************************/

//
// Generating code for EVENT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for EVENT.
 *
 * Do not edit - automatically generated.
 */

// STICKY_EVENT
class unpack_sticky_event : public unpack_sticky_event_base
{
public:
public:
#ifndef __PSDC__
  void __clear_visited() { }
  bool ignore_unknown_subevent() { return false; }
#endif//!__PSDC__

public:
#ifndef __PSDC__
template<typename __data_src_t>
  int __unpack_subevent(subevent_header *__header,__data_src_t &__buffer);
  int __revoke_subevent(subevent_header *__header);
  // void __clean_event();

  STRUCT_FCNS_DECL(unpack_sticky_event);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for EVENT.
 *
 * Do not edit - automatically generated.
 */

// STICKY_EVENT
template<typename __data_src_t>
int unpack_sticky_event::__unpack_subevent(subevent_header *__header,__data_src_t &__buffer)
{
  int __match_no = 0;
  if (!__match_no) return 0;
  switch (__match_no)
  {
  }
  return 0;
}
FORCE_IMPL_DATA_SRC_FCN_HDR(int,unpack_sticky_event::__unpack_subevent);

/** END_UNPACKER ******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for EVENT.
 *
 * Do not edit - automatically generated.
 */

// STICKY_EVENT
{
}

/** END_PACKER ********************************************************/


/** BEGIN_REVOKE *******************************************************
 *
 * Event revoker for EVENT.
 *
 * Do not edit - automatically generated.
 */

// STICKY_EVENT
int unpack_sticky_event::__revoke_subevent(subevent_header *__header)
{
  int __match_no = 0;
  if (!__match_no) return 0;
  switch (__match_no)
  {
  }
  return 0;
}

/** END_REVOKE ********************************************************/


/** BEGIN_SUBEVENT_NAMES ***********************************************
 *
 * Mappings of names for [incl|excl] name lookup.
 *
 * Do not edit - automatically generated.
 */


/** END_SUBEVENT_NAMES ************************************************/


/** BEGIN_UNPACKER_DEFINES *********************************************
 *
 * Control
 *
 * Do not edit - automatically generated.
 */

#define STICKY_EVENT_IS_NONTRIVIAL  0


/** END_UNPACKER_DEFINES **********************************************/

/**********************************************************/
/**********************************************************
 * Generating event structure...
 */


/** BEGIN_EVENT_RAW_STRUCTURE ******************************************
 *
 * Event data structure.
 *
 * Do not edit - automatically generated.
 */

class raw_event_board
{
public:
  DATA8 id;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_board);
#endif//!__PSDC__
} ;

class raw_event_channel_trigger_time
{
public:
//DUMPY: 16 0
  DATA16 hi[16];
//DUMPY: 16 0
  DATA32 lo[16];

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_channel_trigger_time);
#endif//!__PSDC__
} ;

class raw_event_channel_trigger
{
public:
  raw_event_channel_trigger_time
  /* {
  public:
//DUMPY: 16 0
    DATA16 hi[16];
//DUMPY: 16 0
    DATA32 lo[16];
  } */ time;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_channel_trigger);
#endif//!__PSDC__
} ;

class raw_event_channel
{
public:
//DUMPY: 16 0
  DATA8 cfd[16];
//DUMPY: 16 0
  DATA32 energy[16];
//DUMPY: 16 0
  DATA8 id[16];
  raw_event_channel_trigger
  /* {
  public:
    raw_event_channel_trigger_time
    {
    public:
//DUMPY: 16 0
      DATA16 hi[16];
//DUMPY: 16 0
      DATA32 lo[16];
    } time;
  } */ trigger;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_channel);
#endif//!__PSDC__
} ;

class raw_event_event_trigger_time
{
public:
  DATA32 hi;
  DATA32 lo;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_event_trigger_time);
#endif//!__PSDC__
} ;

class raw_event_event_trigger
{
public:
  raw_event_event_trigger_time
  /* {
  public:
    DATA32 hi;
    DATA32 lo;
  } */ time;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_event_trigger);
#endif//!__PSDC__
} ;

class raw_event_event
{
public:
  raw_event_event_trigger
  /* {
  public:
    raw_event_event_trigger_time
    {
    public:
      DATA32 hi;
      DATA32 lo;
    } time;
  } */ trigger;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_event);
#endif//!__PSDC__
} ;

class raw_event_hit
{
public:
  DATA16 pattern;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_hit);
#endif//!__PSDC__
} ;

class raw_event_num_channels
{
public:
  DATA32 fired;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_num_channels);
#endif//!__PSDC__
} ;

class raw_event_num
{
public:
  raw_event_num_channels
  /* {
  public:
    DATA32 fired;
  } */ channels;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_num);
#endif//!__PSDC__
} ;

class raw_event_wr_subsystem
{
public:
  DATA12 id;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_wr_subsystem);
#endif//!__PSDC__
} ;

class raw_event_wr
{
public:
  raw_event_wr_subsystem
  /* {
  public:
    DATA12 id;
  } */ subsystem;
//DUMPY: 4 0
  DATA16 t[4];

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_wr);
#endif//!__PSDC__
} ;

class raw_event : public raw_event_base
{
public:
  raw_event_board
  /* {
  public:
    DATA8 id;
  } */ board;
  raw_event_channel
  /* {
  public:
//DUMPY: 16 0
    DATA8 cfd[16];
//DUMPY: 16 0
    DATA32 energy[16];
//DUMPY: 16 0
    DATA8 id[16];
    raw_event_channel_trigger
    {
    public:
      raw_event_channel_trigger_time
      {
      public:
//DUMPY: 16 0
        DATA16 hi[16];
//DUMPY: 16 0
        DATA32 lo[16];
      } time;
    } trigger;
  } */ channel;
  raw_event_event
  /* {
  public:
    raw_event_event_trigger
    {
    public:
      raw_event_event_trigger_time
      {
      public:
        DATA32 hi;
        DATA32 lo;
      } time;
    } trigger;
  } */ event;
  raw_event_hit
  /* {
  public:
    DATA16 pattern;
  } */ hit;
  raw_event_num
  /* {
  public:
    raw_event_num_channels
    {
    public:
      DATA32 fired;
    } channels;
  } */ num;
//DUMPY: 16 0
  DATA8 overflow[16];
//DUMPY: 16 0
  DATA8 pileup[16];
  raw_event_wr
  /* {
  public:
    raw_event_wr_subsystem
    {
    public:
      DATA12 id;
    } subsystem;
//DUMPY: 4 0
    DATA16 t[4];
  } */ wr;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event);
#endif//!__PSDC__
} ;

/** END_EVENT_RAW_STRUCTURE *******************************************/


/** BEGIN_EVENT_CAL_STRUCTURE ******************************************
 *
 * Event data structure.
 *
 * Do not edit - automatically generated.
 */

class cal_event : public cal_event_base
{
public:

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(cal_event);
#endif//!__PSDC__
} ;

/** END_EVENT_CAL_STRUCTURE *******************************************/


/** BEGIN_EVENT_RAW_STRUCTURE ******************************************
 *
 * Event data structure.
 *
 * Do not edit - automatically generated.
 */

class raw_sticky : public raw_sticky_base
{
public:

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_sticky);
#endif//!__PSDC__
} ;

/** END_EVENT_RAW_STRUCTURE *******************************************/


/** BEGIN_EVENT_DATA_MAPPING *******************************************
 *
 * Event data mapping.
 *
 * Do not edit - automatically generated.
 */

// The order in this file does not matter.
// This information parsed once and not treated eventwise,
// it is used to initialize a structure.

SIGNAL_MAPPING(DATA8,board_id,germanium.data.board_id,board.id);
SIGNAL_MAPPING(DATA8,channel_cfd1,germanium.data.channel_cfd[0],channel.cfd[0]);
SIGNAL_MAPPING(DATA8,channel_cfd10,germanium.data.channel_cfd[9],channel.cfd[9]);
SIGNAL_MAPPING(DATA8,channel_cfd11,germanium.data.channel_cfd[10],channel.cfd[10]);
SIGNAL_MAPPING(DATA8,channel_cfd12,germanium.data.channel_cfd[11],channel.cfd[11]);
SIGNAL_MAPPING(DATA8,channel_cfd13,germanium.data.channel_cfd[12],channel.cfd[12]);
SIGNAL_MAPPING(DATA8,channel_cfd14,germanium.data.channel_cfd[13],channel.cfd[13]);
SIGNAL_MAPPING(DATA8,channel_cfd15,germanium.data.channel_cfd[14],channel.cfd[14]);
SIGNAL_MAPPING(DATA8,channel_cfd16,germanium.data.channel_cfd[15],channel.cfd[15]);
SIGNAL_MAPPING(DATA8,channel_cfd2,germanium.data.channel_cfd[1],channel.cfd[1]);
SIGNAL_MAPPING(DATA8,channel_cfd3,germanium.data.channel_cfd[2],channel.cfd[2]);
SIGNAL_MAPPING(DATA8,channel_cfd4,germanium.data.channel_cfd[3],channel.cfd[3]);
SIGNAL_MAPPING(DATA8,channel_cfd5,germanium.data.channel_cfd[4],channel.cfd[4]);
SIGNAL_MAPPING(DATA8,channel_cfd6,germanium.data.channel_cfd[5],channel.cfd[5]);
SIGNAL_MAPPING(DATA8,channel_cfd7,germanium.data.channel_cfd[6],channel.cfd[6]);
SIGNAL_MAPPING(DATA8,channel_cfd8,germanium.data.channel_cfd[7],channel.cfd[7]);
SIGNAL_MAPPING(DATA8,channel_cfd9,germanium.data.channel_cfd[8],channel.cfd[8]);
SIGNAL_MAPPING(DATA32,channel_energy1,germanium.data.channel_energy[0],channel.energy[0]);
SIGNAL_MAPPING(DATA32,channel_energy10,germanium.data.channel_energy[9],channel.energy[9]);
SIGNAL_MAPPING(DATA32,channel_energy11,germanium.data.channel_energy[10],channel.energy[10]);
SIGNAL_MAPPING(DATA32,channel_energy12,germanium.data.channel_energy[11],channel.energy[11]);
SIGNAL_MAPPING(DATA32,channel_energy13,germanium.data.channel_energy[12],channel.energy[12]);
SIGNAL_MAPPING(DATA32,channel_energy14,germanium.data.channel_energy[13],channel.energy[13]);
SIGNAL_MAPPING(DATA32,channel_energy15,germanium.data.channel_energy[14],channel.energy[14]);
SIGNAL_MAPPING(DATA32,channel_energy16,germanium.data.channel_energy[15],channel.energy[15]);
SIGNAL_MAPPING(DATA32,channel_energy2,germanium.data.channel_energy[1],channel.energy[1]);
SIGNAL_MAPPING(DATA32,channel_energy3,germanium.data.channel_energy[2],channel.energy[2]);
SIGNAL_MAPPING(DATA32,channel_energy4,germanium.data.channel_energy[3],channel.energy[3]);
SIGNAL_MAPPING(DATA32,channel_energy5,germanium.data.channel_energy[4],channel.energy[4]);
SIGNAL_MAPPING(DATA32,channel_energy6,germanium.data.channel_energy[5],channel.energy[5]);
SIGNAL_MAPPING(DATA32,channel_energy7,germanium.data.channel_energy[6],channel.energy[6]);
SIGNAL_MAPPING(DATA32,channel_energy8,germanium.data.channel_energy[7],channel.energy[7]);
SIGNAL_MAPPING(DATA32,channel_energy9,germanium.data.channel_energy[8],channel.energy[8]);
SIGNAL_MAPPING(DATA8,channel_id1,germanium.data.channel_id[0],channel.id[0]);
SIGNAL_MAPPING(DATA8,channel_id10,germanium.data.channel_id[9],channel.id[9]);
SIGNAL_MAPPING(DATA8,channel_id11,germanium.data.channel_id[10],channel.id[10]);
SIGNAL_MAPPING(DATA8,channel_id12,germanium.data.channel_id[11],channel.id[11]);
SIGNAL_MAPPING(DATA8,channel_id13,germanium.data.channel_id[12],channel.id[12]);
SIGNAL_MAPPING(DATA8,channel_id14,germanium.data.channel_id[13],channel.id[13]);
SIGNAL_MAPPING(DATA8,channel_id15,germanium.data.channel_id[14],channel.id[14]);
SIGNAL_MAPPING(DATA8,channel_id16,germanium.data.channel_id[15],channel.id[15]);
SIGNAL_MAPPING(DATA8,channel_id2,germanium.data.channel_id[1],channel.id[1]);
SIGNAL_MAPPING(DATA8,channel_id3,germanium.data.channel_id[2],channel.id[2]);
SIGNAL_MAPPING(DATA8,channel_id4,germanium.data.channel_id[3],channel.id[3]);
SIGNAL_MAPPING(DATA8,channel_id5,germanium.data.channel_id[4],channel.id[4]);
SIGNAL_MAPPING(DATA8,channel_id6,germanium.data.channel_id[5],channel.id[5]);
SIGNAL_MAPPING(DATA8,channel_id7,germanium.data.channel_id[6],channel.id[6]);
SIGNAL_MAPPING(DATA8,channel_id8,germanium.data.channel_id[7],channel.id[7]);
SIGNAL_MAPPING(DATA8,channel_id9,germanium.data.channel_id[8],channel.id[8]);
SIGNAL_MAPPING(DATA16,channel_trigger_time_hi1,germanium.data.channel_trigger_time_hi[0],channel.trigger.time.hi[0]);
SIGNAL_MAPPING(DATA16,channel_trigger_time_hi10,germanium.data.channel_trigger_time_hi[9],channel.trigger.time.hi[9]);
SIGNAL_MAPPING(DATA16,channel_trigger_time_hi11,germanium.data.channel_trigger_time_hi[10],channel.trigger.time.hi[10]);
SIGNAL_MAPPING(DATA16,channel_trigger_time_hi12,germanium.data.channel_trigger_time_hi[11],channel.trigger.time.hi[11]);
SIGNAL_MAPPING(DATA16,channel_trigger_time_hi13,germanium.data.channel_trigger_time_hi[12],channel.trigger.time.hi[12]);
SIGNAL_MAPPING(DATA16,channel_trigger_time_hi14,germanium.data.channel_trigger_time_hi[13],channel.trigger.time.hi[13]);
SIGNAL_MAPPING(DATA16,channel_trigger_time_hi15,germanium.data.channel_trigger_time_hi[14],channel.trigger.time.hi[14]);
SIGNAL_MAPPING(DATA16,channel_trigger_time_hi16,germanium.data.channel_trigger_time_hi[15],channel.trigger.time.hi[15]);
SIGNAL_MAPPING(DATA16,channel_trigger_time_hi2,germanium.data.channel_trigger_time_hi[1],channel.trigger.time.hi[1]);
SIGNAL_MAPPING(DATA16,channel_trigger_time_hi3,germanium.data.channel_trigger_time_hi[2],channel.trigger.time.hi[2]);
SIGNAL_MAPPING(DATA16,channel_trigger_time_hi4,germanium.data.channel_trigger_time_hi[3],channel.trigger.time.hi[3]);
SIGNAL_MAPPING(DATA16,channel_trigger_time_hi5,germanium.data.channel_trigger_time_hi[4],channel.trigger.time.hi[4]);
SIGNAL_MAPPING(DATA16,channel_trigger_time_hi6,germanium.data.channel_trigger_time_hi[5],channel.trigger.time.hi[5]);
SIGNAL_MAPPING(DATA16,channel_trigger_time_hi7,germanium.data.channel_trigger_time_hi[6],channel.trigger.time.hi[6]);
SIGNAL_MAPPING(DATA16,channel_trigger_time_hi8,germanium.data.channel_trigger_time_hi[7],channel.trigger.time.hi[7]);
SIGNAL_MAPPING(DATA16,channel_trigger_time_hi9,germanium.data.channel_trigger_time_hi[8],channel.trigger.time.hi[8]);
SIGNAL_MAPPING(DATA32,channel_trigger_time_lo1,germanium.data.channel_trigger_time_lo[0],channel.trigger.time.lo[0]);
SIGNAL_MAPPING(DATA32,channel_trigger_time_lo10,germanium.data.channel_trigger_time_lo[9],channel.trigger.time.lo[9]);
SIGNAL_MAPPING(DATA32,channel_trigger_time_lo11,germanium.data.channel_trigger_time_lo[10],channel.trigger.time.lo[10]);
SIGNAL_MAPPING(DATA32,channel_trigger_time_lo12,germanium.data.channel_trigger_time_lo[11],channel.trigger.time.lo[11]);
SIGNAL_MAPPING(DATA32,channel_trigger_time_lo13,germanium.data.channel_trigger_time_lo[12],channel.trigger.time.lo[12]);
SIGNAL_MAPPING(DATA32,channel_trigger_time_lo14,germanium.data.channel_trigger_time_lo[13],channel.trigger.time.lo[13]);
SIGNAL_MAPPING(DATA32,channel_trigger_time_lo15,germanium.data.channel_trigger_time_lo[14],channel.trigger.time.lo[14]);
SIGNAL_MAPPING(DATA32,channel_trigger_time_lo16,germanium.data.channel_trigger_time_lo[15],channel.trigger.time.lo[15]);
SIGNAL_MAPPING(DATA32,channel_trigger_time_lo2,germanium.data.channel_trigger_time_lo[1],channel.trigger.time.lo[1]);
SIGNAL_MAPPING(DATA32,channel_trigger_time_lo3,germanium.data.channel_trigger_time_lo[2],channel.trigger.time.lo[2]);
SIGNAL_MAPPING(DATA32,channel_trigger_time_lo4,germanium.data.channel_trigger_time_lo[3],channel.trigger.time.lo[3]);
SIGNAL_MAPPING(DATA32,channel_trigger_time_lo5,germanium.data.channel_trigger_time_lo[4],channel.trigger.time.lo[4]);
SIGNAL_MAPPING(DATA32,channel_trigger_time_lo6,germanium.data.channel_trigger_time_lo[5],channel.trigger.time.lo[5]);
SIGNAL_MAPPING(DATA32,channel_trigger_time_lo7,germanium.data.channel_trigger_time_lo[6],channel.trigger.time.lo[6]);
SIGNAL_MAPPING(DATA32,channel_trigger_time_lo8,germanium.data.channel_trigger_time_lo[7],channel.trigger.time.lo[7]);
SIGNAL_MAPPING(DATA32,channel_trigger_time_lo9,germanium.data.channel_trigger_time_lo[8],channel.trigger.time.lo[8]);
SIGNAL_MAPPING(DATA32,event_trigger_time_hi,germanium.data.event_trigger_time_hi,event.trigger.time.hi);
SIGNAL_MAPPING(DATA32,event_trigger_time_lo,germanium.data.event_trigger_time_lo,event.trigger.time.lo);
SIGNAL_MAPPING(DATA16,hit_pattern,germanium.data.hit_pattern,hit.pattern);
SIGNAL_MAPPING(DATA32,num_channels_fired,germanium.data.num_channels_fired,num.channels.fired);
SIGNAL_MAPPING(DATA8,overflow1,germanium.data.overflow[0],overflow[0]);
SIGNAL_MAPPING(DATA8,overflow10,germanium.data.overflow[9],overflow[9]);
SIGNAL_MAPPING(DATA8,overflow11,germanium.data.overflow[10],overflow[10]);
SIGNAL_MAPPING(DATA8,overflow12,germanium.data.overflow[11],overflow[11]);
SIGNAL_MAPPING(DATA8,overflow13,germanium.data.overflow[12],overflow[12]);
SIGNAL_MAPPING(DATA8,overflow14,germanium.data.overflow[13],overflow[13]);
SIGNAL_MAPPING(DATA8,overflow15,germanium.data.overflow[14],overflow[14]);
SIGNAL_MAPPING(DATA8,overflow16,germanium.data.overflow[15],overflow[15]);
SIGNAL_MAPPING(DATA8,overflow2,germanium.data.overflow[1],overflow[1]);
SIGNAL_MAPPING(DATA8,overflow3,germanium.data.overflow[2],overflow[2]);
SIGNAL_MAPPING(DATA8,overflow4,germanium.data.overflow[3],overflow[3]);
SIGNAL_MAPPING(DATA8,overflow5,germanium.data.overflow[4],overflow[4]);
SIGNAL_MAPPING(DATA8,overflow6,germanium.data.overflow[5],overflow[5]);
SIGNAL_MAPPING(DATA8,overflow7,germanium.data.overflow[6],overflow[6]);
SIGNAL_MAPPING(DATA8,overflow8,germanium.data.overflow[7],overflow[7]);
SIGNAL_MAPPING(DATA8,overflow9,germanium.data.overflow[8],overflow[8]);
SIGNAL_MAPPING(DATA8,pileup1,germanium.data.pileup[0],pileup[0]);
SIGNAL_MAPPING(DATA8,pileup10,germanium.data.pileup[9],pileup[9]);
SIGNAL_MAPPING(DATA8,pileup11,germanium.data.pileup[10],pileup[10]);
SIGNAL_MAPPING(DATA8,pileup12,germanium.data.pileup[11],pileup[11]);
SIGNAL_MAPPING(DATA8,pileup13,germanium.data.pileup[12],pileup[12]);
SIGNAL_MAPPING(DATA8,pileup14,germanium.data.pileup[13],pileup[13]);
SIGNAL_MAPPING(DATA8,pileup15,germanium.data.pileup[14],pileup[14]);
SIGNAL_MAPPING(DATA8,pileup16,germanium.data.pileup[15],pileup[15]);
SIGNAL_MAPPING(DATA8,pileup2,germanium.data.pileup[1],pileup[1]);
SIGNAL_MAPPING(DATA8,pileup3,germanium.data.pileup[2],pileup[2]);
SIGNAL_MAPPING(DATA8,pileup4,germanium.data.pileup[3],pileup[3]);
SIGNAL_MAPPING(DATA8,pileup5,germanium.data.pileup[4],pileup[4]);
SIGNAL_MAPPING(DATA8,pileup6,germanium.data.pileup[5],pileup[5]);
SIGNAL_MAPPING(DATA8,pileup7,germanium.data.pileup[6],pileup[6]);
SIGNAL_MAPPING(DATA8,pileup8,germanium.data.pileup[7],pileup[7]);
SIGNAL_MAPPING(DATA8,pileup9,germanium.data.pileup[8],pileup[8]);
SIGNAL_MAPPING(DATA12,wr_subsystem_id,germanium.ts.subsystem_id,wr.subsystem.id);
SIGNAL_MAPPING(DATA16,wr_t1,germanium.ts.t1,wr.t[0]);
SIGNAL_MAPPING(DATA16,wr_t2,germanium.ts.t2,wr.t[1]);
SIGNAL_MAPPING(DATA16,wr_t3,germanium.ts.t3,wr.t[2]);
SIGNAL_MAPPING(DATA16,wr_t4,germanium.ts.t4,wr.t[3]);

/** END_EVENT_DATA_MAPPING ********************************************/


/** BEGIN_EVENT_DATA_MAPPING *******************************************
 *
 * Event data mapping.
 *
 * Do not edit - automatically generated.
 */

// The order in this file does not matter.
// This information parsed once and not treated eventwise,
// it is used to initialize a structure.


/** END_EVENT_DATA_MAPPING ********************************************/

/**********************************************************/

/** BEGIN_LOCATIONS ****************************************************
 *
 * File and line locations from the parsed specification files.
 *
 * Do not edit - automatically generated.
 */

// It's left to the compiler to only store one copy of each
// unique string.

location spec_locations[] =
{ 
  { 2, 1, "gen_s452a/reparse.uce" },
  { 3, 1, "<built-in>" },
  { 4, 1, "<command-line>" },
  { 5, 1, "/usr/include/stdc-predef.h" },
  { 6, 1, "<command-line>" },
  { 7, 1, "gen_s452a/reparse.uce" },
  { 8, 12, "gen_s452a/reparse.uce" },
  { 223, 235, "gen_s452a/reparse.uce" },
};

/** END_LOCATIONS *****************************************************/


/** BEGIN_ACCOUNT_IDS **************************************************
 *
 * Structure and identifier for raw data items.
 *
 * Do not edit - automatically generated.
 */

account_id _account_ids[] =
{ 
  { 0, "FEBEX_EVENT", "sumchannel" },
  { 1, "FEBEX_EVENT", "channel_size" },
  { 2, "FEBEX_EVENT", "event_timestamp_hi" },
  { 3, "FEBEX_EVENT", "event_timestamp_lo" },
  { 4, "FEBEX_EVENT", "hp" },
  { 5, "FEBEX_EVENT", "deadbeef" },
  { 6, "FEBEX_EVENT", "channelids" },
  { 7, "FEBEX_EVENT", "channel_ts" },
  { 8, "FEBEX_EVENT", "chan_enrgy" },
  { 9, "FEBEX_EVENT", "future_use" },
  { 10, "FEBEX_EVENT", "sumchannel" },
  { 11, "FEBEX_PADDING", "pads_data" },
  { 12, "FEBEX_PADDING", "pads_data" },
  { 13, "TIMESTAMP_WHITERABBIT", "header" },
  { 14, "TIMESTAMP_WHITERABBIT", "d1" },
  { 15, "TIMESTAMP_WHITERABBIT", "d2" },
  { 16, "TIMESTAMP_WHITERABBIT", "d3" },
  { 17, "TIMESTAMP_WHITERABBIT", "d4" },
  { 18, "TIMESTAMP_WHITERABBIT", "header" },
  { 19, "TIMESTAMP_WHITERABBIT_EXTENDED", "header" },
  { 20, "TIMESTAMP_WHITERABBIT_EXTENDED", "d1" },
  { 21, "TIMESTAMP_WHITERABBIT_EXTENDED", "d2" },
  { 22, "TIMESTAMP_WHITERABBIT_EXTENDED", "d3" },
  { 23, "TIMESTAMP_WHITERABBIT_EXTENDED", "d4" },
  { 24, "TIMESTAMP_WHITERABBIT_EXTENDED", "header" },
  { 25, "WR_MULTI", "hi" },
  { 26, "WR_MULTI", "lo" },
  { 27, "WR_MULTI", "hi" },
};

#define NUM_ACCOUNT_IDS  28

/** END_ACCOUNT_IDS ***************************************************/

